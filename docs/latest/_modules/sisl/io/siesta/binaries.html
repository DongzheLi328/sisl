

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>sisl.io.siesta.binaries &mdash; sisl |release| documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> sisl
          

          
          </a>

          
            
            
              <div class="version">
                latest
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contribute.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../other.html">Other resources</a></li>
</ul>
<p class="caption"><span class="caption-text">Publications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../cite.html">Citing sisl</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../publications.html">Publications using sisl</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../scripts/scripts.html">Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst/files.html">File formats</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api.html">API documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">sisl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>sisl.io.siesta.binaries</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for sisl.io.siesta.binaries</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">numbers</span> <span class="k">import</span> <span class="n">Integral</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_siesta</span>
    <span class="n">found_module</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="n">found_module</span> <span class="o">=</span> <span class="kc">False</span>

<span class="kn">from</span> <span class="nn">sisl.messages</span> <span class="k">import</span> <span class="n">warn</span><span class="p">,</span> <span class="n">SislError</span>
<span class="kn">from</span> <span class="nn">..sile</span> <span class="k">import</span> <span class="n">add_sile</span><span class="p">,</span> <span class="n">SileError</span>
<span class="kn">from</span> <span class="nn">.sile</span> <span class="k">import</span> <span class="n">SileBinSiesta</span>

<span class="kn">import</span> <span class="nn">sisl._array</span> <span class="k">as</span> <span class="nn">_a</span>
<span class="kn">from</span> <span class="nn">sisl</span> <span class="k">import</span> <span class="n">Geometry</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">SuperCell</span><span class="p">,</span> <span class="n">Grid</span>
<span class="kn">from</span> <span class="nn">sisl.unit.siesta</span> <span class="k">import</span> <span class="n">unit_convert</span>
<span class="kn">from</span> <span class="nn">sisl.physics.sparse</span> <span class="k">import</span> <span class="n">SparseOrbitalBZ</span>
<span class="kn">from</span> <span class="nn">sisl.physics</span> <span class="k">import</span> <span class="n">Hamiltonian</span><span class="p">,</span> <span class="n">DensityMatrix</span><span class="p">,</span> <span class="n">EnergyDensityMatrix</span>
<span class="kn">from</span> <span class="nn">._help</span> <span class="k">import</span> <span class="o">*</span>


<span class="n">Ang2Bohr</span> <span class="o">=</span> <span class="n">unit_convert</span><span class="p">(</span><span class="s1">&#39;Ang&#39;</span><span class="p">,</span> <span class="s1">&#39;Bohr&#39;</span><span class="p">)</span>
<span class="n">eV2Ry</span> <span class="o">=</span> <span class="n">unit_convert</span><span class="p">(</span><span class="s1">&#39;eV&#39;</span><span class="p">,</span> <span class="s1">&#39;Ry&#39;</span><span class="p">)</span>
<span class="n">Bohr2Ang</span> <span class="o">=</span> <span class="n">unit_convert</span><span class="p">(</span><span class="s1">&#39;Bohr&#39;</span><span class="p">,</span> <span class="s1">&#39;Ang&#39;</span><span class="p">)</span>
<span class="n">Ry2eV</span> <span class="o">=</span> <span class="n">unit_convert</span><span class="p">(</span><span class="s1">&#39;Ry&#39;</span><span class="p">,</span> <span class="s1">&#39;eV&#39;</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;tshsSileSiesta&#39;</span><span class="p">,</span> <span class="s1">&#39;onlysSileSiesta&#39;</span><span class="p">,</span> <span class="s1">&#39;tsdeSileSiesta&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;hsxSileSiesta&#39;</span><span class="p">,</span> <span class="s1">&#39;dmSileSiesta&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;gridSileSiesta&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;tsgfSileSiesta&#39;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_bin_check</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">io_m</span><span class="o">.</span><span class="n">iostat_query</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">.</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">method</span><span class="p">,</span> <span class="n">message</span><span class="p">))</span>


<div class="viewcode-block" id="onlysSileSiesta"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.onlysSileSiesta.html#sisl.io.siesta.onlysSileSiesta">[docs]</a><span class="k">class</span> <span class="nc">onlysSileSiesta</span><span class="p">(</span><span class="n">SileBinSiesta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Geometry and overlap matrix &quot;&quot;&quot;</span>

<div class="viewcode-block" id="onlysSileSiesta.read_supercell"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.onlysSileSiesta.html#sisl.io.siesta.onlysSileSiesta.read_supercell">[docs]</a>    <span class="k">def</span> <span class="nf">read_supercell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a SuperCell object from a siesta.TSHS file &quot;&quot;&quot;</span>
        <span class="n">n_s</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_supercell&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read sizes.&#39;</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">n_s</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_supercell&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read cell.&#39;</span><span class="p">)</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">cell</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SuperCell</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">nsc</span><span class="o">=</span><span class="n">nsc</span><span class="p">)</span></div>

<div class="viewcode-block" id="onlysSileSiesta.read_geometry"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.onlysSileSiesta.html#sisl.io.siesta.onlysSileSiesta.read_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">read_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns Geometry object from a siesta.TSHS file &quot;&quot;&quot;</span>

        <span class="c1"># Read supercell</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_supercell</span><span class="p">()</span>

        <span class="n">na</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_geometry&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read sizes.&#39;</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_geom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">na</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_geometry&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read geometry.&#39;</span><span class="p">)</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">xyz</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">lasto</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># Create all different atoms...</span>
        <span class="c1"># The TSHS file does not contain the</span>
        <span class="c1"># atomic numbers, so we will just</span>
        <span class="c1"># create them individually</span>
        <span class="n">orbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">lasto</span><span class="p">)</span>

        <span class="c1"># Get unique orbitals</span>
        <span class="n">uorb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">orbs</span><span class="p">)</span>
        <span class="c1"># Create atoms</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">Z</span><span class="p">,</span> <span class="n">orb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">uorb</span><span class="p">):</span>
            <span class="n">atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Atom</span><span class="p">(</span><span class="n">Z</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">orb</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">get_atom</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">orbs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">no</span> <span class="o">==</span> <span class="n">orbs</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">atom</span>

        <span class="n">atom</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">orb</span> <span class="ow">in</span> <span class="n">orbs</span><span class="p">:</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_atom</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">orb</span><span class="p">))</span>

        <span class="c1"># Create and return geometry object</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">geom</span></div>

<div class="viewcode-block" id="onlysSileSiesta.read_overlap"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.onlysSileSiesta.html#sisl.io.siesta.onlysSileSiesta.read_overlap">[docs]</a>    <span class="k">def</span> <span class="nf">read_overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the overlap matrix from the siesta.TSHS file &quot;&quot;&quot;</span>
        <span class="n">tshs_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">()</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">tshs_g</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span> <span class="o">!=</span> <span class="n">tshs_g</span><span class="o">.</span><span class="n">na</span> <span class="ow">or</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span> <span class="o">!=</span> <span class="n">tshs_g</span><span class="o">.</span><span class="n">no</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.read_overlap could not use the &#39;</span>
                            <span class="s1">&#39;passed geometry as the number of atoms or orbitals is &#39;</span>
                            <span class="s1">&#39;inconsistent with TSHS file.&#39;</span><span class="p">)</span>

        <span class="c1"># Ensure that the number of supercells is correct</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">nsc</span> <span class="o">!=</span> <span class="n">tshs_g</span><span class="o">.</span><span class="n">nsc</span><span class="p">):</span>
            <span class="n">geom</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">tshs_g</span><span class="o">.</span><span class="n">nsc</span><span class="p">)</span>

        <span class="c1"># read the sizes used...</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_overlap&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read sizes.&#39;</span><span class="p">)</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">3</span><span class="p">])[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_overlap&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read cell.&#39;</span><span class="p">)</span>
        <span class="n">no</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">nnz</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dS</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_overlap&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read overlap matrix.&#39;</span><span class="p">)</span>

        <span class="c1"># Create the Hamiltonian container</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">SparseOrbitalBZ</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">ncol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dS</span><span class="p">[:]</span>

        <span class="c1"># Convert to sisl supercell</span>
        <span class="n">_csr_from_sc_off</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">isc</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">S</span></div></div>


<div class="viewcode-block" id="tshsSileSiesta"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.tshsSileSiesta.html#sisl.io.siesta.tshsSileSiesta">[docs]</a><span class="k">class</span> <span class="nc">tshsSileSiesta</span><span class="p">(</span><span class="n">onlysSileSiesta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Geometry, Hamiltonian and overlap matrix file &quot;&quot;&quot;</span>

<div class="viewcode-block" id="tshsSileSiesta.read_hamiltonian"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.tshsSileSiesta.html#sisl.io.siesta.tshsSileSiesta.read_hamiltonian">[docs]</a>    <span class="k">def</span> <span class="nf">read_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the electronic structure from the siesta.TSHS file &quot;&quot;&quot;</span>
        <span class="n">tshs_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">()</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">tshs_g</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span> <span class="o">!=</span> <span class="n">tshs_g</span><span class="o">.</span><span class="n">na</span> <span class="ow">or</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span> <span class="o">!=</span> <span class="n">tshs_g</span><span class="o">.</span><span class="n">no</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.read_hamiltonian could not use the &#39;</span>
                            <span class="s1">&#39;passed geometry as the number of atoms or orbitals is inconsistent &#39;</span>
                            <span class="s1">&#39;with TSHS file.&#39;</span><span class="p">)</span>

        <span class="c1"># Ensure that the number of supercells is correct</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">nsc</span> <span class="o">!=</span> <span class="n">tshs_g</span><span class="o">.</span><span class="n">nsc</span><span class="p">):</span>
            <span class="n">geom</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">tshs_g</span><span class="o">.</span><span class="n">nsc</span><span class="p">)</span>

        <span class="c1"># read the sizes used...</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read sizes.&#39;</span><span class="p">)</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">3</span><span class="p">])[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read cell.&#39;</span><span class="p">)</span>
        <span class="n">spin</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">no</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">nnz</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dH</span><span class="p">,</span> <span class="n">dS</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_hs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read Hamiltonian and overlap matrix.&#39;</span><span class="p">)</span>

        <span class="c1"># Check whether it is an orthogonal basis set</span>
        <span class="n">orthogonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dS</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span>

        <span class="c1"># Create the Hamiltonian container</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">Hamiltonian</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">orthogonal</span><span class="o">=</span><span class="n">orthogonal</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">ncol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">orthogonal</span><span class="p">:</span>
            <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="n">spin</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">dH</span><span class="p">[:,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="n">spin</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dH</span><span class="p">[:,</span> <span class="p">:]</span>
            <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dS</span><span class="p">[:]</span>

        <span class="c1"># Convert to sisl supercell</span>
        <span class="n">_csr_from_sc_off</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">isc</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

        <span class="c1"># Find all indices where dS == 1 (remember col is in fortran indices)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">dS</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">idx</span> <span class="o">&gt;</span> <span class="n">no</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of orbitals: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">no</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.read_hamiltonian could not assert &#39;</span>
                            <span class="s1">&#39;the supercell connections in the primary unit-cell.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">H</span></div>

<div class="viewcode-block" id="tshsSileSiesta.write_hamiltonian"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.tshsSileSiesta.html#sisl.io.siesta.tshsSileSiesta.write_hamiltonian">[docs]</a>    <span class="k">def</span> <span class="nf">write_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Writes the Hamiltonian to a siesta.TSHS file &quot;&quot;&quot;</span>
        <span class="n">H</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">csr</span><span class="o">.</span><span class="n">nnz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.write_hamiltonian cannot write &#39;</span>
                            <span class="s1">&#39;a zero element sparse matrix!&#39;</span><span class="p">)</span>

        <span class="c1"># Convert to siesta CSR</span>
        <span class="n">_csr_to_siesta</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">csr</span><span class="p">)</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>

        <span class="c1"># Extract the data to pass to the fortran routine</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">cell</span> <span class="o">*</span> <span class="n">Ang2Bohr</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">xyz</span> <span class="o">*</span> <span class="n">Ang2Bohr</span>

        <span class="c1"># Get H and S</span>
        <span class="k">if</span> <span class="n">H</span><span class="o">.</span><span class="n">orthogonal</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">*</span> <span class="n">eV2Ry</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Ensure all data is correctly formatted (i.e. have the same sparsity pattern</span>
            <span class="n">s</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">csr</span><span class="p">)</span>
            <span class="n">s</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">nnz</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="s1">&#39;The diagonal elements of your orthogonal Hamiltonian &#39;</span>
                                <span class="s1">&#39;have not been defined, this is a requirement.&#39;</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">H</span><span class="o">.</span><span class="n">S_idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">eV2Ry</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">H</span><span class="o">.</span><span class="n">S_idx</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Ensure shapes (say if only 1 spin)</span>
        <span class="n">h</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">spin</span><span class="p">))</span>
        <span class="n">s</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>

        <span class="c1"># Get shorter variants</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">nsc</span><span class="p">[:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">siesta_sc_off</span><span class="p">(</span><span class="o">*</span><span class="n">nsc</span><span class="p">)</span>

        <span class="c1"># I can&#39;t seem to figure out the usage of f2py</span>
        <span class="c1"># Below I get an error if xyz is not transposed and h is transposed,</span>
        <span class="c1"># however, they are both in C-contiguous arrays and this is indeed weird... :(</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">write_tshs_hs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                              <span class="n">cell</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">xyz</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">firsto</span><span class="p">,</span>
                              <span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">,</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">isc</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;write_hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;could not write Hamiltonian and overlap matrix.&#39;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="dmSileSiesta"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.dmSileSiesta.html#sisl.io.siesta.dmSileSiesta">[docs]</a><span class="k">class</span> <span class="nc">dmSileSiesta</span><span class="p">(</span><span class="n">SileBinSiesta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Density matrix file &quot;&quot;&quot;</span>

<div class="viewcode-block" id="dmSileSiesta.read_density_matrix"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.dmSileSiesta.html#sisl.io.siesta.dmSileSiesta.read_density_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">read_density_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the density matrix from the siesta.DM file &quot;&quot;&quot;</span>

        <span class="c1"># Now read the sizes used...</span>
        <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">nsc</span><span class="p">,</span> <span class="n">nnz</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_dm_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_density_matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read density matrix sizes.&#39;</span><span class="p">)</span>

        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dDM</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_dm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">nsc</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_density_matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read density matrix.&#39;</span><span class="p">)</span>

        <span class="c1"># Try and immediately attach a geometry</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geom&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">geom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We truly, have no clue,</span>
            <span class="c1"># Just generate a boxed system</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no</span><span class="p">)]</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">SuperCell</span><span class="p">([</span><span class="n">no</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">nsc</span><span class="o">=</span><span class="n">nsc</span><span class="p">)</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">Atom</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">nsc</span> <span class="o">!=</span> <span class="n">nsc</span><span class="p">):</span>
            <span class="c1"># We have to update the number of supercells!</span>
            <span class="n">geom</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">nsc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span> <span class="o">!=</span> <span class="n">no</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.read_density_matrix could not use the &#39;</span>
                            <span class="s1">&#39;passed geometry as the number of atoms or orbitals is &#39;</span>
                            <span class="s1">&#39;inconsistent with DM file.&#39;</span><span class="p">)</span>

        <span class="c1"># Create the density matrix container</span>
        <span class="n">DM</span> <span class="o">=</span> <span class="n">DensityMatrix</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">orthogonal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">ncol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="n">spin</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dDM</span><span class="p">[:,</span> <span class="p">:]</span>
        <span class="c1"># DM file does not contain overlap matrix... so neglect it for now.</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="c1"># Convert the supercells to sisl supercells</span>
        <span class="k">if</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">geom</span><span class="o">.</span><span class="n">no_s</span> <span class="o">&gt;=</span> <span class="n">col</span><span class="o">.</span><span class="n">max</span><span class="p">():</span>
            <span class="n">_csr_from_siesta</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.read_density_matrix may result in a wrong sparse pattern!&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">DM</span></div>

<div class="viewcode-block" id="dmSileSiesta.write_density_matrix"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.dmSileSiesta.html#sisl.io.siesta.dmSileSiesta.write_density_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">write_density_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DM</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Writes the density matrix to a siesta.DM file &quot;&quot;&quot;</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">csr</span><span class="o">.</span><span class="n">nnz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.write_density_matrix cannot write &#39;</span>
                            <span class="s1">&#39;a zero element sparse matrix!&#39;</span><span class="p">)</span>

        <span class="n">_csr_to_siesta</span><span class="p">(</span><span class="n">DM</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">csr</span><span class="p">)</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>

        <span class="c1"># Get H and S</span>
        <span class="k">if</span> <span class="n">DM</span><span class="o">.</span><span class="n">orthogonal</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">DM</span><span class="o">.</span><span class="n">S_idx</span><span class="p">]</span>

        <span class="c1"># Ensure shapes (say if only 1 spin)</span>
        <span class="n">dm</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">DM</span><span class="o">.</span><span class="n">spin</span><span class="p">))</span>

        <span class="n">nsc</span> <span class="o">=</span> <span class="n">DM</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">nsc</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="n">_siesta</span><span class="o">.</span><span class="n">write_dm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">nsc</span><span class="p">,</span> <span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">,</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;write_density_matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;could not write density matrix.&#39;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="tsdeSileSiesta"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.tsdeSileSiesta.html#sisl.io.siesta.tsdeSileSiesta">[docs]</a><span class="k">class</span> <span class="nc">tsdeSileSiesta</span><span class="p">(</span><span class="n">dmSileSiesta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Non-equilibrium density matrix and energy density matrix file &quot;&quot;&quot;</span>

<div class="viewcode-block" id="tsdeSileSiesta.read_energy_density_matrix"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.tsdeSileSiesta.html#sisl.io.siesta.tsdeSileSiesta.read_energy_density_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">read_energy_density_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the energy density matrix from the siesta.DM file &quot;&quot;&quot;</span>

        <span class="c1"># Now read the sizes used...</span>
        <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">nsc</span><span class="p">,</span> <span class="n">nnz</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tsde_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_energy_density_matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read energy density matrix sizes.&#39;</span><span class="p">)</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dEDM</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tsde_edm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">nsc</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_energy_density_matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read energy density matrix.&#39;</span><span class="p">)</span>

        <span class="c1"># Try and immediately attach a geometry</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geom&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">geom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We truly, have no clue,</span>
            <span class="c1"># Just generate a boxed system</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no</span><span class="p">)]</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">SuperCell</span><span class="p">([</span><span class="n">no</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">nsc</span><span class="o">=</span><span class="n">nsc</span><span class="p">)</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">Atom</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">nsc</span> <span class="o">!=</span> <span class="n">nsc</span><span class="p">):</span>
            <span class="c1"># We have to update the number of supercells!</span>
            <span class="n">geom</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">nsc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span> <span class="o">!=</span> <span class="n">no</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.read_energy_density_matrix could &#39;</span>
                            <span class="s1">&#39;not use the passed geometry as the number of atoms or orbitals &#39;</span>
                            <span class="s1">&#39;is inconsistent with DM file.&#39;</span><span class="p">)</span>

        <span class="c1"># Create the energy density matrix container</span>
        <span class="n">EDM</span> <span class="o">=</span> <span class="n">EnergyDensityMatrix</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">orthogonal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">ncol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="n">spin</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dEDM</span><span class="p">[:,</span> <span class="p">:]</span>
        <span class="c1"># EDM file does not contain overlap matrix... so neglect it for now.</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="c1"># Convert the supercells to sisl supercells</span>
        <span class="k">if</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">geom</span><span class="o">.</span><span class="n">no_s</span> <span class="o">&gt;=</span> <span class="n">col</span><span class="o">.</span><span class="n">max</span><span class="p">():</span>
            <span class="n">_csr_from_siesta</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.read_energy_density_matrix may &#39;</span>
                 <span class="s1">&#39;result in a wrong sparse pattern!&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">EDM</span></div></div>


<div class="viewcode-block" id="hsxSileSiesta"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.hsxSileSiesta.html#sisl.io.siesta.hsxSileSiesta">[docs]</a><span class="k">class</span> <span class="nc">hsxSileSiesta</span><span class="p">(</span><span class="n">SileBinSiesta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Hamiltonian and overlap matrix file &quot;&quot;&quot;</span>

<div class="viewcode-block" id="hsxSileSiesta.read_hamiltonian"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.hsxSileSiesta.html#sisl.io.siesta.hsxSileSiesta.read_hamiltonian">[docs]</a>    <span class="k">def</span> <span class="nf">read_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the electronic structure from the siesta.TSHS file &quot;&quot;&quot;</span>

        <span class="c1"># Now read the sizes used...</span>
        <span class="n">Gamma</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read Hamiltonian sizes.&#39;</span><span class="p">)</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dH</span><span class="p">,</span> <span class="n">dS</span><span class="p">,</span> <span class="n">dxij</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_hsx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">Gamma</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read Hamiltonian.&#39;</span><span class="p">)</span>

        <span class="c1"># Try and immediately attach a geometry</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geom&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">geom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We have *no* clue about the</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">dxij</span><span class="p">,</span> <span class="mf">0.</span><span class="p">):</span>
                <span class="c1"># We truly, have no clue,</span>
                <span class="c1"># Just generate a boxed system</span>
                <span class="n">xyz</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no</span><span class="p">)]</span>
                <span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">Atom</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">sc</span><span class="o">=</span><span class="p">[</span><span class="n">no</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Try to figure out the supercell</span>
                <span class="n">warn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.read_hamiltonian &#39;</span>
                     <span class="s1">&#39;(currently we can not calculate atomic positions from xij array)&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span> <span class="o">!=</span> <span class="n">no</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.read_hamiltonian could not use the &#39;</span>
                            <span class="s1">&#39;passed geometry as the number of atoms or orbitals is &#39;</span>
                            <span class="s1">&#39;inconsistent with HSX file.&#39;</span><span class="p">)</span>

        <span class="c1"># Create the Hamiltonian container</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">Hamiltonian</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">orthogonal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">ncol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="n">spin</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dH</span><span class="p">[:,</span> <span class="p">:]</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dS</span><span class="p">[:]</span>

        <span class="c1"># Convert the supercells to sisl supercells</span>
        <span class="k">if</span> <span class="n">no_s</span> <span class="o">//</span> <span class="n">no</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">nsc</span><span class="p">):</span>
            <span class="n">_csr_from_siesta</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">H</span></div>

<div class="viewcode-block" id="hsxSileSiesta.read_overlap"><a class="viewcode-back" href="../../../../api-generated/sisl.io.siesta.hsxSileSiesta.html#sisl.io.siesta.hsxSileSiesta.read_overlap">[docs]</a>    <span class="k">def</span> <span class="nf">read_overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the overlap matrix from the siesta.HSX file &quot;&quot;&quot;</span>
        <span class="c1"># Now read the sizes used...</span>
        <span class="n">Gamma</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_overlap&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read overlap matrix sizes.&#39;</span><span class="p">)</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dS</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">Gamma</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_overlap&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read overlap matrix.&#39;</span><span class="p">)</span>

        <span class="n">geom</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geom&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">geom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;.read_overlap requires input geometry to assign S&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span> <span class="o">!=</span> <span class="n">no</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.read_overlap could not use the &#39;</span>
                            <span class="s1">&#39;passed geometry as the number of atoms or orbitals is &#39;</span>
                            <span class="s1">&#39;inconsistent with HSX file.&#39;</span><span class="p">)</span>

        <span class="c1"># Create the Hamiltonian container</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">SparseOrbitalBZ</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">ncol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dS</span><span class="p">[:]</span>

        <span class="c1"># Convert the supercells to sisl supercells</span>
        <span class="k">if</span> <span class="n">no_s</span> <span class="o">//</span> <span class="n">no</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">nsc</span><span class="p">):</span>
            <span class="n">_csr_from_siesta</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">S</span></div></div>


<span class="k">class</span> <span class="nc">_gridSileSiesta</span><span class="p">(</span><span class="n">SileBinSiesta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Binary real-space grid file</span>

<span class="sd">    The Siesta binary grid sile will automatically convert the units from Siesta</span>
<span class="sd">    units (Bohr, Ry) to sisl units (Ang, eV) provided the correct extension is present.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">read_supercell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">cell</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_grid_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_supercell&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read cell.&#39;</span><span class="p">)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">cell</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">SuperCell</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read grid contained in the Grid file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int or array_like, optional</span>
<span class="sd">           the spin-index for retrieving one of the components. If a vector</span>
<span class="sd">           is passed it refers to the fraction per indexed component. I.e.</span>
<span class="sd">           ``[0.5, 0.5]`` will return sum of half the first two components.</span>
<span class="sd">           Default to the first component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Read the sizes</span>
        <span class="n">nspin</span><span class="p">,</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_grid_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_grid&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read grid sizes.&#39;</span><span class="p">)</span>
        <span class="c1"># Read the cell and grid</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_grid_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_grid&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read grid cell.&#39;</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">nspin</span><span class="p">,</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_grid&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read grid.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">index</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.read_grid requires spin to be an integer or &#39;</span>
                                 <span class="s1">&#39;an array of length equal to the number of spin components.&#39;</span><span class="p">)</span>
            <span class="c1"># It is F-contiguous, hence the last index</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">scale</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="n">g</span> <span class="o">+=</span> <span class="n">grid</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">g</span>

        <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">cell</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Simply create the grid (with no information)</span>
        <span class="c1"># We will overwrite the actual grid</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">sc</span><span class="o">=</span><span class="n">SuperCell</span><span class="p">(</span><span class="n">cell</span><span class="p">))</span>
        <span class="c1"># NOTE: there is no need to swap-axes since the returned array is in F ordering</span>
        <span class="c1">#       and thus the first axis is the fast (x, y, z) is retained</span>
        <span class="n">g</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="n">grid</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_unit</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">g</span>


<span class="k">class</span> <span class="nc">_gfSileSiesta</span><span class="p">(</span><span class="n">SileBinSiesta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Surface Green function file containing, Hamiltonian, overlap matrix and self-energies</span>

<span class="sd">    Do not mix read and write statements when using this code. Complete one or the other</span>
<span class="sd">    before doing the other thing. Fortran does not allow the same file opened twice, if this</span>
<span class="sd">    is needed you are recommended to make a symlink to the file and thus open two different</span>
<span class="sd">    files.</span>

<span class="sd">    This small snippet reads/writes the GF file</span>

<span class="sd">    &gt;&gt;&gt; with sisl.io._gfSileSiesta(&#39;hello.GF&#39;) as f:</span>
<span class="sd">    ...    nspin, no, k, E = f.read_header()</span>
<span class="sd">    ...    for ispin, new_k, k, E in f:</span>
<span class="sd">    ...        if new_k:</span>
<span class="sd">    ...            H, S = f.read_hamiltonian()</span>
<span class="sd">    ...        SeHSE = f.read_self_energy()</span>

<span class="sd">    To write a file do:</span>

<span class="sd">    &gt;&gt;&gt; with sisl.io._gfSileSiesta(&#39;hello.GF&#39;) as f:</span>
<span class="sd">    ...    f.write_header(sisl.MonkhorstPack(...), E)</span>
<span class="sd">    ...    for ispin, new_k, k, E in f:</span>
<span class="sd">    ...        if new_k:</span>
<span class="sd">    ...            f.write_hamiltonian(H, S)</span>
<span class="sd">    ...        f.write_self_energy(SeHSE)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Simple setup that needs to be overwritten &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_iu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_is_open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iu</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_open_gf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_iu</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_open_gf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_iu</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">write_open_gf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_open_gf&#39;</span><span class="p">,</span> <span class="s1">&#39;could not open for </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">({</span><span class="s1">&#39;r&#39;</span><span class="p">:</span> <span class="s1">&#39;reading&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="s1">&#39;writing&#39;</span><span class="p">}[</span><span class="n">mode</span><span class="p">]))</span>

        <span class="c1"># Counters to keep track</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ie</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_close_gf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_open</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="c1"># Close it</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">close_gf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_iu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># Clean variables</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ie</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">read_header</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read the header of the file and open it for reading subsequently</span>

<span class="sd">        NOTES: this method may change in the future</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nspin : number of spin-components stored (1 or 2)</span>
<span class="sd">        no_u : size of the matrices returned</span>
<span class="sd">        k : k points in the GF file</span>
<span class="sd">        E : energy points in the GF file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure it is open (in read-mode)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_gf</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_open_gf</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">nspin</span><span class="p">,</span> <span class="n">no_u</span><span class="p">,</span> <span class="n">nkpt</span><span class="p">,</span> <span class="n">NE</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_gf_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_header&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read sizes.&#39;</span><span class="p">)</span>

        <span class="c1"># We need to re-read (because of k-points)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_gf</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_open_gf</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>

        <span class="n">k</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_gf_header</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="n">nkpt</span><span class="p">,</span> <span class="n">NE</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_header&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read header information.&#39;</span><span class="p">)</span>

        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">=</span> <span class="n">nspin</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span> <span class="o">=</span> <span class="n">no_u</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span> <span class="o">=</span> <span class="n">no_u</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_E</span> <span class="o">=</span> <span class="n">E</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">k</span>
        <span class="k">return</span> <span class="n">nspin</span><span class="p">,</span> <span class="n">no_u</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">E</span> <span class="o">*</span> <span class="n">Ry2eV</span>

    <span class="k">def</span> <span class="nf">disk_usage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the estimated size of the resulting file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        estimated disk-space used in GB</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_open</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_open</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_open</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_header</span><span class="p">()</span>

        <span class="c1"># HS are only stored per k-point</span>
        <span class="n">HS</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">)</span>
        <span class="n">SE</span> <span class="o">=</span> <span class="n">HS</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_E</span><span class="p">)</span>

        <span class="c1"># Now calculate the full size</span>
        <span class="c1"># no_u ** 2 = matrix size</span>
        <span class="c1"># 16 = bytes in double complex</span>
        <span class="c1"># 1024 ** 3 = B -&gt; GB</span>
        <span class="n">mem</span> <span class="o">=</span> <span class="p">(</span><span class="n">HS</span> <span class="o">+</span> <span class="n">SE</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">/</span> <span class="mi">1024</span> <span class="o">**</span> <span class="mi">3</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_open</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_close_gf</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">mem</span>

    <span class="k">def</span> <span class="nf">read_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return current Hamiltonian and overlap matrix from the GF file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        complex128 : Hamiltonian matrix</span>
<span class="sd">        complex128 : Overlap matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ie</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">H</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_gf_hs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read Hamiltonian and overlap matrices.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">H</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">Ry2eV</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">T</span>

    <span class="k">def</span> <span class="nf">read_self_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Read the currently reached bulk self-energy</span>

<span class="sd">        The returned self-energy is:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \boldsymbol \Sigma_{\mathrm{bulk}}(E) = \mathbf S E - \mathbf H - \boldsymbol \Sigma(E)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        complex128 : Self-energy matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">SE</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_gf_se</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ie</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">Ry2eV</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;read_self_energy&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read self-energy.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ie</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">SE</span>

    <span class="k">def</span> <span class="nf">write_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bz</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Write to the binary file the header of the file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bz : BrillouinZone</span>
<span class="sd">           contains the k-points, the weights and possibly the parent Hamiltonian (if `obj` is None)s</span>
<span class="sd">        E : array_like of cmplx or float</span>
<span class="sd">           the energy points. If `obj` is an instance of `SelfEnergy` where an</span>
<span class="sd">           associated ``eta`` is defined then `E` may be float, otherwise</span>
<span class="sd">           it *has* to be a complex array.</span>
<span class="sd">        mu : float, optional</span>
<span class="sd">           chemical potential in the file</span>
<span class="sd">        obj : ..., optional</span>
<span class="sd">           an object that contains the Hamiltonian definitions, defaults to ``bz.parent``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">bz</span><span class="o">.</span><span class="n">parent</span>
        <span class="n">nspin</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">spin</span><span class="p">)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">cell</span> <span class="o">*</span> <span class="n">Ang2Bohr</span>
        <span class="n">na_u</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">na</span>
        <span class="n">no_u</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span>
        <span class="n">xa</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">xyz</span> <span class="o">*</span> <span class="n">Ang2Bohr</span>
        <span class="c1"># The lasto in siesta requires lasto(0) == 0</span>
        <span class="c1"># and secondly, the Python index to fortran</span>
        <span class="c1"># index makes firsto behave like fortran lasto</span>
        <span class="n">lasto</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">firsto</span>
        <span class="n">bloch</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">onesi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">eV2Ry</span>
        <span class="n">NE</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">E</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">]:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">obj</span><span class="o">.</span><span class="n">eta</span>
        <span class="n">Nk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bz</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">bz</span><span class="o">.</span><span class="n">k</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">bz</span><span class="o">.</span><span class="n">weight</span>

        <span class="n">sizes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;na_used&#39;</span><span class="p">:</span> <span class="n">na_u</span><span class="p">,</span>
            <span class="s1">&#39;nkpt&#39;</span><span class="p">:</span> <span class="n">Nk</span><span class="p">,</span>
            <span class="s1">&#39;ne&#39;</span><span class="p">:</span> <span class="n">NE</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">=</span> <span class="n">nspin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">*</span> <span class="n">eV2Ry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span> <span class="o">=</span> <span class="n">no_u</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span> <span class="o">=</span> <span class="n">no_u</span>

        <span class="c1"># Ensure it is open (in write mode)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_gf</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_open_gf</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>

        <span class="c1"># Now write to it...</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">write_gf_header</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="n">nspin</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">na_u</span><span class="p">,</span> <span class="n">no_u</span><span class="p">,</span> <span class="n">no_u</span><span class="p">,</span> <span class="n">xa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">lasto</span><span class="p">,</span>
                                <span class="n">bloch</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E</span><span class="p">,</span> <span class="o">**</span><span class="n">sizes</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;write_header&#39;</span><span class="p">,</span> <span class="s1">&#39;could not write header information.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Write the current energy, k-point and H and S to the file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        H : matrix</span>
<span class="sd">           a square matrix corresponding to the Hamiltonian</span>
<span class="sd">        S : matrix, optional</span>
<span class="sd">           a square matrix corresponding to the overlap, for efficiency reasons</span>
<span class="sd">           it may be advantageous to specify this argument for orthogonal cells.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ie</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">no</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">no</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">write_gf_hs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ie</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_ie</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                            <span class="n">H</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">eV2Ry</span><span class="p">,</span>
                            <span class="n">S</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">no_u</span><span class="o">=</span><span class="n">no</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;write_hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;could not write Hamiltonian and overlap matrices.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_self_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SE</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Write the current self energy, k-point and H and S to the file</span>

<span class="sd">        The self-energy must correspond to the *bulk* self-energy</span>

<span class="sd">        .. math::</span>
<span class="sd">            \boldsymbol \Sigma_{\mathrm{bulk}}(E) = \mathbf S E - \mathbf H - \boldsymbol \Sigma(E)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        SE : matrix</span>
<span class="sd">           a square matrix corresponding to the self-energy (Green function)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">no</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">SE</span><span class="p">)</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">write_gf_se</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ie</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_E</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_ie</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                            <span class="n">SE</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">eV2Ry</span><span class="p">,</span> <span class="n">no_u</span><span class="o">=</span><span class="n">no</span><span class="p">)</span>
        <span class="n">_bin_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;write_self_energy&#39;</span><span class="p">,</span> <span class="s1">&#39;could not write self-energy.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ie</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_E</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Iterate through the energies and k-points that this GF file is associated with</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        bool, list of float, float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get everything</span>
        <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E</span> <span class="o">*</span> <span class="n">Ry2eV</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">ispin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">ispin</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">E</span> <span class="ow">in</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                        <span class="k">yield</span> <span class="n">ispin</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">E</span>

                <span class="c1"># Reset counters for k and e</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ie</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">:</span>
                <span class="k">yield</span> <span class="kc">True</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">E</span> <span class="ow">in</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="k">yield</span> <span class="kc">False</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">E</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ie</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># We will automatically close once we hit the end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_gf</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">dic</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">dic</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dic</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Always pass the docstring</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;__doc__&#39;</span> <span class="ow">in</span> <span class="n">dic</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dic</span><span class="p">[</span><span class="s1">&#39;__doc__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__doc__</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">),</span> <span class="n">dic</span><span class="p">)</span>

<span class="c1"># Faster than class ... \ pass</span>
<span class="n">tsgfSileSiesta</span> <span class="o">=</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;tsgfSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gfSileSiesta</span><span class="p">)</span>
<span class="n">gridSileSiesta</span> <span class="o">=</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;gridSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="p">})</span>

<span class="k">if</span> <span class="n">found_module</span><span class="p">:</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;TSHS&#39;</span><span class="p">,</span> <span class="n">tshsSileSiesta</span><span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;onlyS&#39;</span><span class="p">,</span> <span class="n">onlysSileSiesta</span><span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;TSDE&#39;</span><span class="p">,</span> <span class="n">tsdeSileSiesta</span><span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;DM&#39;</span><span class="p">,</span> <span class="n">dmSileSiesta</span><span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;HSX&#39;</span><span class="p">,</span> <span class="n">hsxSileSiesta</span><span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;TSGF&#39;</span><span class="p">,</span> <span class="n">tsgfSileSiesta</span><span class="p">)</span>
    <span class="c1"># These have unit-conversions</span>
    <span class="n">BohrC2AngC</span> <span class="o">=</span> <span class="n">Bohr2Ang</span> <span class="o">**</span> <span class="mi">3</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;RHO&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;rhoSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">BohrC2AngC</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;RHOINIT&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;rhoinitSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">BohrC2AngC</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;RHOXC&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;rhoxcSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">BohrC2AngC</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;DRHO&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;drhoSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">BohrC2AngC</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;BADER&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;baderSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">BohrC2AngC</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;IOCH&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;iorhoSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">BohrC2AngC</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;TOCH&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;totalrhoSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">BohrC2AngC</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;VH&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;hartreeSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="n">Ry2eV</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;VNA&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;neutralatomhartreeSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="n">Ry2eV</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;VT&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;totalhartreeSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="n">Ry2eV</span><span class="p">}))</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2018, Nick R. Papior

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>