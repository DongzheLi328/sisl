

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>sisl.sparse_geometry &mdash; sisl |release| documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> sisl
          

          
          </a>

          
            
            
              <div class="version">
                latest
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../other.html">Other resources</a></li>
</ul>
<p class="caption"><span class="caption-text">Publications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../cite.html">Citing sisl</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../publications.html">Publications using sisl</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scripts/scripts.html">Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rst/files.html">File formats</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">sisl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>sisl.sparse_geometry</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for sisl.sparse_geometry</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">functools</span> <span class="k">as</span> <span class="nn">ftool</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="k">import</span> <span class="n">Integral</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">int32</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">insert</span><span class="p">,</span> <span class="n">unique</span><span class="p">,</span> <span class="n">take</span><span class="p">,</span> <span class="n">delete</span><span class="p">,</span> <span class="n">argsort</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">tile</span><span class="p">,</span> <span class="n">repeat</span><span class="p">,</span> <span class="n">concatenate</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_array</span> <span class="k">as</span> <span class="n">_a</span>
<span class="kn">from</span> <span class="nn">.atom</span> <span class="k">import</span> <span class="n">Atom</span>
<span class="kn">from</span> <span class="nn">.orbital</span> <span class="k">import</span> <span class="n">Orbital</span>
<span class="kn">from</span> <span class="nn">.geometry</span> <span class="k">import</span> <span class="n">Geometry</span>
<span class="kn">from</span> <span class="nn">.messages</span> <span class="k">import</span> <span class="n">warn</span><span class="p">,</span> <span class="n">SislError</span><span class="p">,</span> <span class="n">SislWarning</span><span class="p">,</span> <span class="n">tqdm_eta</span>
<span class="kn">from</span> <span class="nn">._indices</span> <span class="k">import</span> <span class="n">indices_only</span>
<span class="kn">from</span> <span class="nn">._help</span> <span class="k">import</span> <span class="n">get_dtype</span>
<span class="kn">from</span> <span class="nn">._help</span> <span class="k">import</span> <span class="n">_zip</span> <span class="k">as</span> <span class="nb">zip</span><span class="p">,</span> <span class="n">_range</span> <span class="k">as</span> <span class="nb">range</span><span class="p">,</span> <span class="n">_map</span> <span class="k">as</span> <span class="nb">map</span>
<span class="kn">from</span> <span class="nn">.utils.ranges</span> <span class="k">import</span> <span class="n">array_arange</span>
<span class="kn">from</span> <span class="nn">.sparse</span> <span class="k">import</span> <span class="n">SparseCSR</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;SparseAtom&#39;</span><span class="p">,</span> <span class="s1">&#39;SparseOrbital&#39;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">_SparseGeometry</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Sparse object containing sparse elements for a given geometry.</span>

<span class="sd">    This is a base class intended to be sub-classed because the sparsity information</span>
<span class="sd">    needs to be extracted from the ``_size`` attribute.</span>

<span class="sd">    The sub-classed object _must_ implement the ``_size`` attribute.</span>
<span class="sd">    The sub-classed object may re-implement the ``_cls_kwargs`` routine</span>
<span class="sd">    to pass down keyword arguments when a new class is instantiated.</span>

<span class="sd">    This object contains information regarding the</span>
<span class="sd">     - geometry</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># These overrides are necessary to be able to perform</span>
    <span class="c1"># ufunc operations with numpy.</span>
    <span class="c1"># The reason is that the ufunc in numpy arrays are first</span>
    <span class="c1"># tried when encountering operations:</span>
    <span class="c1">#   np.int + object will invoke __add__ from ndarray, regardless</span>
    <span class="c1"># of objects __radd__ routine.</span>
    <span class="c1"># We thus need to define the ufunc method in this object</span>
    <span class="c1"># to tell numpy that using numpy.ndarray.__array_ufunc__ won&#39;t work.</span>
    <span class="c1"># Prior to 1.13 the ufunc is named numpy_ufunc, subsequent versions</span>
    <span class="c1"># are using array_ufunc.</span>
    <span class="n">__numpy_ufunc__</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">__array_ufunc__</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create sparse object with element between orbitals &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">geometry</span>

        <span class="c1"># Initialize the sparsity pattern</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">nnzpr</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Associated geometry &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometry</span>
    <span class="n">geom</span> <span class="o">=</span> <span class="n">geometry</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The size of the sparse object &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">na</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Number of rows in the basis &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>

    <span class="k">def</span> <span class="nf">_cls_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Custom keyword arguments when creating a new instance &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The sparsity pattern has all elements removed and everything is reset.</span>

<span class="sd">        The object will be the same as if it had been</span>
<span class="sd">        initialized with the same geometry as it were</span>
<span class="sd">        created with.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim: int, optional</span>
<span class="sd">           number of dimensions per element, default to the current number of</span>
<span class="sd">           elements per matrix element.</span>
<span class="sd">        dtype: numpy.dtype, optional</span>
<span class="sd">           the datatype of the sparse elements</span>
<span class="sd">        nnzpr: int, optional</span>
<span class="sd">           number of non-zero elements per row</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># I know that this is not the most efficient way to</span>
        <span class="c1"># access a C-array, however, for constructing a</span>
        <span class="c1"># sparse pattern, it should be faster if memory elements</span>
        <span class="c1"># are closer...</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span>

        <span class="c1"># We check the first atom and its neighbours, we then</span>
        <span class="c1"># select max(5,len(nc) * 4)</span>
        <span class="k">if</span> <span class="n">nnzpr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nnzpr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nnzpr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">nnzpr</span> <span class="o">=</span> <span class="mi">8</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nnzpr</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nnzpr</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>

        <span class="c1"># query dimension of sparse matrix</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">SparseCSR</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">n_s</span><span class="p">,</span> <span class="n">dim</span><span class="p">),</span> <span class="n">nnzpr</span><span class="o">=</span><span class="n">nnzpr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Denote that one *must* specify all details of the elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep_nnz</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; See :meth:`~sparse.SparseCSR.empty` for details &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">keep_nnz</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A copy of this object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : numpy.dtype, optional</span>
<span class="sd">           it is possible to convert the data to a different data-type</span>
<span class="sd">           If not specified, it will use ``self.dtype``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>
        <span class="c1"># Be sure to copy the content of the SparseCSR object</span>
        <span class="n">new</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Number of components per element &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Shape of sparse matrix &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Data type of sparse elements &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dkind</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Data type of sparse elements (in str) &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">dkind</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nnz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Number of non-zero elements &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">nnz</span>

    <span class="k">def</span> <span class="nf">_translate_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Translates all columns in the `old` cell indices to the `new` cell indices</span>

<span class="sd">        Since the physical matrices are stored in a CSR form, with shape ``(no, no * n_s)`` each</span>
<span class="sd">        block of ``(no, no)`` refers to supercell matrices with an offset according to the internal</span>
<span class="sd">        supercell index.</span>
<span class="sd">        This routine may be used to translate from one sorting of the columns to another sorting of the columns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        old : list of int</span>
<span class="sd">           integer list of supercell indices (all smaller than `n_s`) that the current blocks of matrices</span>
<span class="sd">           belong to.</span>
<span class="sd">        new : list of int</span>
<span class="sd">           integer list of supercell indices (all smaller than `n_s`) that the current blocks of matrices</span>
<span class="sd">           are being transferred to. Must have same length as `old`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">old</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">new</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="o">+</span><span class="s2">&quot;.translate_cells requires input and output indices with &quot;</span>
                             <span class="s2">&quot;equal length&quot;</span><span class="p">)</span>

        <span class="n">no</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
        <span class="c1"># Number of elements per matrix</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyi</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">))</span>
        <span class="n">n</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">no</span><span class="p">)</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">old</span> <span class="o">*</span> <span class="n">no</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">new</span> <span class="o">*</span> <span class="n">no</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">translate_columns</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Retrieve edges (connections) of a given `atom` or list of `atom`&#39;s</span>

<span class="sd">        The returned edges are unique and sorted (see `numpy.unique`) and are returned</span>
<span class="sd">        in supercell indices (i.e. ``0 &lt;= edge &lt; self.geometry.na_s``).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : int or list of int</span>
<span class="sd">            the edges are returned only for the given atom</span>
<span class="sd">        exclude : int or list of int, optional</span>
<span class="sd">           remove edges which are in the `exclude` list.</span>
<span class="sd">           Default to `atom`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        SparseCSR.edges: the underlying routine used for extracting the edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">exclude</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Representation of the sparse model &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;{{dim: </span><span class="si">{0}</span><span class="s1">, non-zero: </span><span class="si">{1}</span><span class="s1">, kind=</span><span class="si">{2}</span><span class="se">\n</span><span class="s1"> &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dkind</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> &#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">}&#39;</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Overload attributes from the hosting geometry</span>

<span class="sd">        Any attribute not found in the sparse class will</span>
<span class="sd">        be looked up in the hosting geometry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

    <span class="c1"># Make the indicis behave on the contained sparse matrix</span>
    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Delete elements of the sparse elements &quot;&quot;&quot;</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Check whether a sparse index is non-zero &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>

    <span class="k">def</span> <span class="nf">set_nsc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reset the number of allowed supercells in the sparse geometry</span>

<span class="sd">        If one reduces the number of supercells, *any* sparse element</span>
<span class="sd">        that references the supercell will be deleted.</span>

<span class="sd">        See `SuperCell.set_nsc` for allowed parameters.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        SuperCell.set_nsc : the underlying called method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Try first in the new one, then we figure out what to do</span>
        <span class="n">sc</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">nsc</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">nsc</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="c1"># Create an array of all things that should be translated</span>
        <span class="n">old</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">deleted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        <span class="n">deleted</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sc_off</span> <span class="ow">in</span> <span class="n">sc</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Luckily there are *only* one time wrap-arounds</span>
                <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">sc_off</span><span class="p">)</span>
                <span class="c1"># Now do translation</span>
                <span class="n">old</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">deleted</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># Not found, i.e. new, so no need to translate</span>
                <span class="k">pass</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">n_s</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="s2">&quot;Not all supercells are accounted for&quot;</span><span class="p">)</span>

        <span class="c1"># 1. Ensure that any one of the *old* supercells that</span>
        <span class="c1">#    are now deleted are put in the end</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">deleted</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># Old index (j)</span>
            <span class="n">old</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="c1"># Move to the end (*HAS* to be higher than the number of</span>
            <span class="c1"># cells in the new supercell structure)</span>
            <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">n_s</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>

        <span class="n">old</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>

        <span class="c1"># Assert that there are only unique values</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">old</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="s2">&quot;non-unique values in old set_nsc&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">new</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="s2">&quot;non-unique values in new set_nsc&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_s</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="s2">&quot;non-valid size of in old set_nsc&quot;</span><span class="p">)</span>

        <span class="c1"># Figure out if we need to do any work</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="p">(</span><span class="n">old</span> <span class="o">!=</span> <span class="n">new</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Reduce pivoting work</span>
            <span class="n">old</span> <span class="o">=</span> <span class="n">old</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">new</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>

            <span class="c1"># Create the translation tables</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">tile</span><span class="p">([</span><span class="n">size</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">))</span>

            <span class="n">old</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">old</span> <span class="o">*</span> <span class="n">size</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">new</span> <span class="o">*</span> <span class="n">size</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>

            <span class="c1"># Move data to new positions</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">translate_columns</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>

            <span class="n">max_n</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_n</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Make sure we delete all column values where we have put fake values</span>
        <span class="n">delete</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">n_s</span> <span class="o">*</span> <span class="n">size</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">delete</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">delete_columns</span><span class="p">(</span><span class="n">delete</span><span class="p">,</span> <span class="n">keep_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Ensure the shape is correct</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span> <span class="o">*</span> <span class="n">sc</span><span class="o">.</span><span class="n">n_s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create the transposed sparse geometry by interchanging supercell indices</span>

<span class="sd">        Sparse geometries are (typically) relying on symmetry in the supercell picture.</span>
<span class="sd">        Thus when one transposes a sparse geometry one should *ideally* get the same</span>
<span class="sd">        matrix. This is true for the Hamiltonian, density matrix, etc.</span>

<span class="sd">        This routine transposes all rows and columns such that any interaction between</span>
<span class="sd">        row, `r`, and column `c` in a given supercell `(i,j,k)` will be transposed</span>
<span class="sd">        into row `c`, column `r` in the supercell `(-i,-j,-k)`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For Hamiltonians with non-collinear or spin-orbit there is no transposing of the</span>
<span class="sd">        sub-spin matrix box. This needs to be done *manually*.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Force a sparse geometry to be Hermitian:</span>

<span class="sd">        &gt;&gt;&gt; sp = SparseOrbital(...)</span>
<span class="sd">        &gt;&gt;&gt; sp = (sp + sp.transpose()) * 0.5</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        object</span>
<span class="sd">            an equivalent sparse geometry with transposed matrix elements</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a temporary copy to put data into</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Short-linkes</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc</span>

        <span class="c1"># Create &quot;DOK&quot; format indices</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>
        <span class="c1"># Number of rows (used for converting to supercell indices)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># First extract the actual data</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">csr</span><span class="o">.</span><span class="n">finalized</span><span class="p">:</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">ptr</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">ncol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">cumsumi</span><span class="p">(</span><span class="n">ncol</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">idx</span>

        <span class="c1"># Create an array ready for holding all transposed columns</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosi</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">))</span>
        <span class="n">row</span><span class="p">[</span><span class="n">ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">_a</span><span class="o">.</span><span class="n">cumsumi</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">row</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Now we have the DOK format</span>
        <span class="c1">#  row, col, _D</span>

        <span class="c1"># Retrieve all sc-indices in the new transposed array</span>
        <span class="n">new_sc_off</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="o">-</span> <span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">)</span>

        <span class="c1"># Calculate the row-offsets in the new sparse geometry</span>
        <span class="n">row</span> <span class="o">+=</span> <span class="n">new_sc_off</span><span class="p">[</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">col</span> <span class="o">//</span> <span class="n">size</span><span class="p">,</span> <span class="p">:])]</span> <span class="o">*</span> <span class="n">size</span>

        <span class="c1"># Now convert columns into unit-cell</span>
        <span class="n">col</span> <span class="o">%=</span> <span class="n">size</span>

        <span class="c1"># Now we can re-create the sparse matrix</span>
        <span class="c1"># All we need is to count the number of non-zeros per column.</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">nrow</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Now we have everything ready...</span>
        <span class="c1"># Simply figure out how to sort the columns</span>
        <span class="c1"># such that we have them unified.</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">argsort</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="c1"># Our new data will then be</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">take</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">row</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">row</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">take</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">D</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">nrow</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">cumsumi</span><span class="p">(</span><span class="n">nrow</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># For-sure we haven&#39;t sorted the columns.</span>
        <span class="c1"># We haven&#39;t changed the number of non-zeros</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">T</span>

    <span class="k">def</span> <span class="nf">spalign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; See :meth:`~sisl.sparse.SparseCSR.align` for details &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SparseCSR</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eliminate_zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Removes all zero elements from the sparse matrix</span>

<span class="sd">        This is an *in-place* operation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atol : float, optional</span>
<span class="sd">            absolute tolerance equal or below this value will be considered 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">(</span><span class="n">atol</span><span class="p">)</span>

    <span class="c1"># Create iterations on the non-zero elements</span>
    <span class="k">def</span> <span class="nf">iter_nnz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Iterations of the non-zero elements</span>

<span class="sd">        An iterator on the sparse matrix with, row and column</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; for i, j in self.iter_nnz():</span>
<span class="sd">        ...    self[i, j] # is then the non-zero value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span>

    <span class="fm">__iter__</span> <span class="o">=</span> <span class="n">iter_nnz</span>

    <span class="k">def</span> <span class="nf">create_construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a simple function for passing to the `construct` function.</span>

<span class="sd">        This is simply to leviate the creation of simplistic</span>
<span class="sd">        functions needed for setting up the sparse elements.</span>

<span class="sd">        Basically this returns a function:</span>

<span class="sd">        &gt;&gt;&gt; def func(self, ia, idxs, idxs_xyz=None):</span>
<span class="sd">        ...     idx = self.geometry.close(ia, R=R, idx=idxs)</span>
<span class="sd">        ...     for ix, p in zip(idx, param):</span>
<span class="sd">        ...         self[ia, ix] = p</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function only works for geometry sparse matrices (i.e. one</span>
<span class="sd">        element per atom). If you have more than one element per atom</span>
<span class="sd">        you have to implement the function your-self.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        R : array_like</span>
<span class="sd">           radii parameters for different shells.</span>
<span class="sd">           Must have same length as `param` or one less.</span>
<span class="sd">           If one less it will be extended with ``R[0]/100``</span>
<span class="sd">        param : array_like</span>
<span class="sd">           coupling constants corresponding to the `R`</span>
<span class="sd">           ranges. ``param[0,:]`` are the elements</span>
<span class="sd">           for the all atoms within ``R[0]`` of each atom.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        construct : routine to create the sparse matrix from a generic function (as returned from `create_construct`)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">idxs</span><span class="p">,</span> <span class="n">idxs_xyz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="n">idxs</span><span class="p">,</span> <span class="n">idx_xyz</span><span class="o">=</span><span class="n">idxs_xyz</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>

        <span class="k">return</span> <span class="n">func</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">na_iR</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;rand&#39;</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Automatically construct the sparse model based on a function that does the setting up of the elements</span>

<span class="sd">        This may be called in two variants.</span>

<span class="sd">        1. Pass a function (`func`), see e.g. ``create_construct``</span>
<span class="sd">           which does the setting up.</span>
<span class="sd">        2. Pass a tuple/list in `func` which consists of two</span>
<span class="sd">           elements, one is ``R`` the radii parameters for</span>
<span class="sd">           the corresponding parameters.</span>
<span class="sd">           The second is the parameters</span>
<span class="sd">           corresponding to the ``R[i]`` elements.</span>
<span class="sd">           In this second case all atoms must only have</span>
<span class="sd">           one orbital.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func: callable or array_like</span>
<span class="sd">           this function *must* take 4 arguments.</span>
<span class="sd">           1. Is this object (``self``)</span>
<span class="sd">           2. Is the currently examined atom (``ia``)</span>
<span class="sd">           3. Is the currently bounded indices (``idxs``)</span>
<span class="sd">           4. Is the currently bounded indices atomic coordinates (``idxs_xyz``)</span>
<span class="sd">           An example `func` could be:</span>

<span class="sd">           &gt;&gt;&gt; def func(self, ia, idxs, idxs_xyz=None):</span>
<span class="sd">           ...     idx = self.geometry.close(ia, R=[0.1, 1.44], idx=idxs, idx_xyz=idxs_xyz)</span>
<span class="sd">           ...     self[ia, idx[0]] = 0</span>
<span class="sd">           ...     self[ia, idx[1]] = -2.7</span>

<span class="sd">        na_iR : int, optional</span>
<span class="sd">           number of atoms within the sphere for speeding</span>
<span class="sd">           up the `iter_block` loop.</span>
<span class="sd">        method : {&#39;rand&#39;, str}</span>
<span class="sd">           method used in `Geometry.iter_block`, see there for details</span>
<span class="sd">        eta: bool, optional</span>
<span class="sd">           whether an ETA will be printed</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        create_construct : a generic function used to create a generic function which this routine requires</span>
<span class="sd">        tile : tiling *after* construct is much faster for very large systems</span>
<span class="sd">        repeat : repeating *after* construct is much faster for very large systems</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Passed `func` which is not a function, nor tuple/list of `R, param`&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">lasto</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Automatically setting a sparse model &quot;</span>
                              <span class="s2">&quot;for systems with atoms having more than 1 &quot;</span>
                              <span class="s2">&quot;orbital *must* be done by your-self. You have to define a corresponding `func`.&quot;</span><span class="p">)</span>

            <span class="c1"># Convert to a proper function</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_construct</span><span class="p">(</span><span class="n">func</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">func</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">iR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">iR</span><span class="p">(</span><span class="n">na_iR</span><span class="p">)</span>

        <span class="c1"># Create eta-object</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="n">tqdm_eta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.construct&#39;</span><span class="p">,</span> <span class="s1">&#39;atom&#39;</span><span class="p">,</span> <span class="n">eta</span><span class="p">)</span>

        <span class="c1"># Do the loop</span>
        <span class="k">for</span> <span class="n">ias</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">iter_block</span><span class="p">(</span><span class="n">iR</span><span class="o">=</span><span class="n">iR</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">):</span>

            <span class="c1"># Get all the indexed atoms...</span>
            <span class="c1"># This speeds up the searching for coordinates...</span>
            <span class="n">idxs_xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="n">idxs</span><span class="p">,</span> <span class="p">:]</span>

            <span class="c1"># Loop the atoms inside</span>
            <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">ias</span><span class="p">:</span>
                <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">idxs</span><span class="p">,</span> <span class="n">idxs_xyz</span><span class="p">)</span>

            <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ias</span><span class="p">))</span>

        <span class="n">eta</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">finalized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Whether the contained data is finalized and non-used elements have been removed &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">finalized</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a subset of this sparse matrix by removing the atoms corresponding to `atom`</span>

<span class="sd">        Negative indices are wrapped and thus works.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : array_like of int</span>
<span class="sd">            indices of removed atoms</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Geometry.remove : equivalent to the resulting `Geometry` from this routine</span>
<span class="sd">        Geometry.sub : the negative of `Geometry.remove`</span>
<span class="sd">        sub : the opposite of `remove`, i.e. retain a subset of atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">),</span> <span class="n">atom</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a subset of this sparse matrix by retaining the atoms corresponding to `atom`</span>

<span class="sd">        Indices passed must be unique.</span>

<span class="sd">        Negative indices are wrapped and thus works.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : array_like of int</span>
<span class="sd">            indices of removed atoms</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Geometry.remove : equivalent to the resulting `Geometry` from this routine</span>
<span class="sd">        Geometry.sub : the negative of `Geometry.remove`</span>
<span class="sd">        remove : the negative of `sub`, i.e. remove a subset of atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Swaps atoms in the sparse geometry to obtain a new order of atoms</span>

<span class="sd">        This can be used to reorder elements of a geometry.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : array_like</span>
<span class="sd">             the first list of atomic coordinates</span>
<span class="sd">        b : array_like</span>
<span class="sd">             the second list of atomic coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="c1"># Create full index list</span>
        <span class="n">full</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">))</span>
        <span class="c1"># Regardless of whether swapping or new indices are requested</span>
        <span class="c1"># this should work.</span>
        <span class="n">full</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
        <span class="n">full</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">full</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Finalizes the model</span>

<span class="sd">        Finalizes the model so that all non-used elements are removed. I.e. this simply reduces the memory requirement for the sparse matrix.</span>

<span class="sd">        Note that adding more elements to the sparse matrix is more time-consuming than for a non-finalized sparse matrix due to the</span>
<span class="sd">        internal data-representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">tocsr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return a :class:`~scipy.sparse.csr_matrix` for the specified dimension</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : int, optional</span>
<span class="sd">           the dimension in the sparse matrix (for non-orthogonal cases the last</span>
<span class="sd">           dimension is the overlap matrix)</span>
<span class="sd">        isc : int, optional</span>
<span class="sd">           the supercell index, or all (if ``isc=None``)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">isc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Requesting sub-sparse has not been implemented yet&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">tocsr</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">spsame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compare two sparse objects and check whether they have the same entries.</span>

<span class="sd">        This does not necessarily mean that the elements are the same</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">spsame</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromsp</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">geom</span><span class="p">,</span> <span class="o">*</span><span class="n">sp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a sparse model from a preset Geometry and a list of sparse matrices &quot;&quot;&quot;</span>
        <span class="c1"># Ensure it is a list (no tuples can be used)</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sp</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="c1"># Downcast to a single list of sparse matrices</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument should be a single list or a sequence of arguments, not both.&quot;</span><span class="p">)</span>
                <span class="n">sp</span> <span class="o">=</span> <span class="n">s</span>
                <span class="k">break</span>

        <span class="c1"># Number of dimensions</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">nnzpr</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># Sort all indices for the passed sparse matrices</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
            <span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sort_indices</span><span class="p">()</span>
            <span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sum_duplicates</span><span class="p">()</span>

            <span class="c1"># Figure out the maximum connections per</span>
            <span class="c1"># row to reduce number of re-allocations to 0</span>
            <span class="n">nnzpr</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nnzpr</span><span class="p">,</span> <span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">nnz</span> <span class="o">//</span> <span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Create the sparse object</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">sp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">nnzpr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">S</span><span class="o">.</span><span class="n">_size</span> <span class="o">!=</span> <span class="n">sp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.fromsp cannot create a new class, the geometry &#39;</span> <span class="o">+</span> \
                             <span class="s1">&#39;and sparse matrices does not have coinciding dimensions size != sp.shape[0]&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">indptr</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

            <span class="c1"># loop and add elements</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">ptr</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">S</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">col</span><span class="p">[</span><span class="n">sl</span><span class="p">],</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">S</span>

    <span class="c1">###############################</span>
    <span class="c1"># Overload of math operations #</span>
    <span class="c1">###############################</span>
    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">get_dtype</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="n">c</span> <span class="o">+=</span> <span class="n">b</span>
        <span class="k">return</span> <span class="n">c</span>
    <span class="fm">__radd__</span> <span class="o">=</span> <span class="fm">__add__</span>

    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">_SparseGeometry</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span> <span class="o">+=</span> <span class="n">b</span><span class="o">.</span><span class="n">_csr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span> <span class="o">+=</span> <span class="n">b</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">get_dtype</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="n">c</span> <span class="o">-=</span> <span class="n">b</span>
        <span class="k">return</span> <span class="n">c</span>

    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">_SparseGeometry</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">get_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
            <span class="n">c</span><span class="o">.</span><span class="n">_csr</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">c</span>

    <span class="k">def</span> <span class="nf">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">_SparseGeometry</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span> <span class="o">-=</span> <span class="n">b</span><span class="o">.</span><span class="n">_csr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span> <span class="o">-=</span> <span class="n">b</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">get_dtype</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="n">c</span> <span class="o">*=</span> <span class="n">b</span>
        <span class="k">return</span> <span class="n">c</span>
    <span class="fm">__rmul__</span> <span class="o">=</span> <span class="fm">__mul__</span>

    <span class="k">def</span> <span class="nf">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">_SparseGeometry</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span> <span class="o">*=</span> <span class="n">b</span><span class="o">.</span><span class="n">_csr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span> <span class="o">*=</span> <span class="n">b</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">get_dtype</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="n">c</span> <span class="o">/=</span> <span class="n">b</span>
        <span class="k">return</span> <span class="n">c</span>

    <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">get_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="n">c</span> <span class="o">/=</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">c</span>

    <span class="k">def</span> <span class="nf">__idiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">_SparseGeometry</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span> <span class="o">/=</span> <span class="n">b</span><span class="o">.</span><span class="n">_csr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span> <span class="o">/=</span> <span class="n">b</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">_SparseGeometry</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">get_dtype</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="n">c</span> <span class="o">//=</span> <span class="n">b</span>
        <span class="k">return</span> <span class="n">c</span>

    <span class="k">def</span> <span class="nf">__ifloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">_SparseGeometry</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span> <span class="o">//=</span> <span class="n">b</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">_SparseGeometry</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">get_dtype</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="n">c</span> <span class="o">/=</span> <span class="n">b</span>
        <span class="k">return</span> <span class="n">c</span>

    <span class="k">def</span> <span class="nf">__itruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">_SparseGeometry</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span> <span class="o">/=</span> <span class="n">b</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">get_dtype</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="n">c</span> <span class="o">**=</span> <span class="n">b</span>
        <span class="k">return</span> <span class="n">c</span>

    <span class="k">def</span> <span class="nf">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">get_dtype</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="n">c</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">b</span> <span class="o">**</span> <span class="n">c</span><span class="o">.</span><span class="n">_csr</span>
        <span class="k">return</span> <span class="n">c</span>

    <span class="k">def</span> <span class="nf">__ipow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">_SparseGeometry</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span> <span class="o">**=</span> <span class="n">b</span><span class="o">.</span><span class="n">_csr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span> <span class="o">**=</span> <span class="n">b</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return dictionary with the current state &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;csr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return dictionary with the current state &quot;&quot;&quot;</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">Atom</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">geom</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">geom</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="n">SparseCSR</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;csr&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">csr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>


<div class="viewcode-block" id="SparseAtom"><a class="viewcode-back" href="../../api-generated/sisl.SparseAtom.html#sisl.SparseAtom">[docs]</a><span class="k">class</span> <span class="nc">SparseAtom</span><span class="p">(</span><span class="n">_SparseGeometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Sparse object with number of rows equal to the total number of atoms in the `Geometry` &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Elements for the index(s) &quot;&quot;&quot;</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># This may be a specification of supercell indices</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="c1"># We guess it is the supercell index</span>
                <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">key</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">off</span>
        <span class="k">if</span> <span class="n">dd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">dd</span><span class="p">,)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set or create elements in the sparse data</span>

<span class="sd">        Override set item for slicing operations and enables easy</span>
<span class="sd">        setting of parameters in a sparse matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># This may be a specification of supercell indices</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="c1"># We guess it is the supercell index</span>
                <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">key</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">off</span>
        <span class="k">if</span> <span class="n">dd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">dd</span><span class="p">,)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">na</span>

<div class="viewcode-block" id="SparseAtom.nonzero"><a class="viewcode-back" href="../../api-generated/sisl.SparseAtom.html#sisl.SparseAtom.nonzero">[docs]</a>    <span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">only_col</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Indices row and column indices where non-zero elements exists</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : int or array_like of int, optional</span>
<span class="sd">           only return the tuples for the requested atoms, default is all atoms</span>
<span class="sd">        only_col : bool, optional</span>
<span class="sd">           only return then non-zero columns</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        SparseCSR.nonzero : the equivalent function call</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">row</span><span class="o">=</span><span class="n">atom</span><span class="p">,</span> <span class="n">only_col</span><span class="o">=</span><span class="n">only_col</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseAtom.iter_nnz"><a class="viewcode-back" href="../../api-generated/sisl.SparseAtom.html#sisl.SparseAtom.iter_nnz">[docs]</a>    <span class="k">def</span> <span class="nf">iter_nnz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Iterations of the non-zero elements</span>

<span class="sd">        An iterator on the sparse matrix with, row and column</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; for i, j in self.iter_nnz():</span>
<span class="sd">        ...    self[i, j] # is then the non-zero value</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : int or array_like</span>
<span class="sd">            only loop on the non-zero elements coinciding with the atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">iter_nnz</span><span class="p">(</span><span class="n">atom</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">iter_nnz</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span></div>

<div class="viewcode-block" id="SparseAtom.set_nsc"><a class="viewcode-back" href="../../api-generated/sisl.SparseAtom.html#sisl.SparseAtom.set_nsc">[docs]</a>    <span class="k">def</span> <span class="nf">set_nsc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reset the number of allowed supercells in the sparse atom</span>

<span class="sd">        If one reduces the number of supercells *any* sparse element</span>
<span class="sd">        that references the supercell will be deleted.</span>

<span class="sd">        See `SuperCell.set_nsc` for allowed parameters.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        SuperCell.set_nsc : the underlying called method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SparseAtom</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseAtom.cut"><a class="viewcode-back" href="../../api-generated/sisl.SparseAtom.html#sisl.SparseAtom.cut">[docs]</a>    <span class="k">def</span> <span class="nf">cut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seps</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Cuts the sparse atom model into different parts.</span>

<span class="sd">        Recreates a new sparse atom object with only the cutted</span>
<span class="sd">        atoms in the structure.</span>

<span class="sd">        Cutting is the opposite of tiling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        seps : int</span>
<span class="sd">           number of times the structure will be cut</span>
<span class="sd">        axis : int</span>
<span class="sd">           the axis that will be cut</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_w</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Create new geometry</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
            <span class="c1"># Cause all warnings to always be triggered.</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;always&quot;</span><span class="p">)</span>
            <span class="c1"># Create new cut geometry</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">seps</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># Check whether the warning exists</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">category</span><span class="p">,</span> <span class="n">SislWarning</span><span class="p">):</span>
                    <span class="n">new_w</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
                    <span class="n">new_w</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">---</span><span class="se">\n</span><span class="s2">&quot;</span>
                              <span class="s2">&quot;The sparse atom cannot be cut as the structure &quot;</span>
                              <span class="s2">&quot;cannot be tiled accordingly. ANY use of the model has been &quot;</span>
                              <span class="s2">&quot;relieved from sisl.&quot;</span><span class="p">)</span>
                    <span class="n">warn</span><span class="p">(</span><span class="n">new_w</span><span class="p">)</span>

        <span class="c1"># Now we need to re-create number of supercells</span>
        <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tocsr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># First we need to figure out how long the interaction range is</span>
        <span class="c1"># in the cut-direction</span>
        <span class="c1"># We initialize to be the same as the parent direction</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsc</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># we count the new direction</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosi</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">out</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">out</span><span class="p">:</span>
            <span class="c1"># Get supercell index</span>
            <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">sub</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">geom</span><span class="o">.</span><span class="n">na</span><span class="p">,</span> <span class="n">idx</span> <span class="o">*</span> <span class="n">na</span><span class="p">:(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">na</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">[:]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">c_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span>
            <span class="c1"># Count the number of cells it interacts with</span>
            <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_max</span> <span class="o">%</span> <span class="n">na</span><span class="p">)</span> <span class="o">//</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span>
            <span class="n">ic</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">*</span> <span class="n">na</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">ic</span> <span class="o">+</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span> <span class="o">*</span> <span class="n">j</span>
                <span class="c1"># We need to ensure that every &quot;in between&quot; index exists</span>
                <span class="c1"># if it does not we discard those indices</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">sub</span><span class="p">,</span>
                                      <span class="n">sub</span> <span class="o">&lt;</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
            <span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">*</span> <span class="n">seps</span> <span class="o">+</span> <span class="n">i</span>

            <span class="k">if</span> <span class="n">out</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Cut the connection at nsc=</span><span class="si">{0}</span><span class="s1"> in direction </span><span class="si">{1}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">axis</span><span class="p">))</span>

        <span class="c1"># Update number of super-cells</span>
        <span class="n">nsc</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">nsc</span><span class="p">[:]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">geom</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">nsc</span><span class="p">)</span>

        <span class="c1"># Now we have a correct geometry, and</span>
        <span class="c1"># we are now ready to create the sparsity pattern</span>
        <span class="c1"># Reduce the sparsity pattern, first create the new one</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>

        <span class="k">def</span> <span class="nf">_sca2sca</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">seps</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
            <span class="c1"># Converts an o from M to m</span>
            <span class="n">isc</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">a2isc</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
            <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">*</span> <span class="n">seps</span>
            <span class="c1"># Correct for cell-offset</span>
            <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span> <span class="o">%</span> <span class="n">M</span><span class="o">.</span><span class="n">na</span><span class="p">)</span> <span class="o">//</span> <span class="n">m</span><span class="o">.</span><span class="n">na</span>
            <span class="c1"># find the equivalent cell in m</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># If a fail happens it is due to a discarded</span>
                <span class="c1"># interaction across a non-interacting region</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">%</span> <span class="n">m</span><span class="o">.</span><span class="n">na</span><span class="p">,</span>
                        <span class="n">m</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="o">.</span><span class="n">na</span><span class="p">,</span>
                        <span class="n">m</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="o">-</span><span class="n">isc</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># only loop on the atoms remaining in the cutted structure</span>
        <span class="k">for</span> <span class="n">ja</span><span class="p">,</span> <span class="n">ia</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_nnz</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">na</span><span class="p">)):</span>

            <span class="c1"># Get the equivalent orbital in the smaller cell</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">afp</span><span class="p">,</span> <span class="n">afm</span> <span class="o">=</span> <span class="n">_sca2sca</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">geom</span><span class="p">,</span> <span class="n">seps</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">S</span><span class="p">[</span><span class="n">ja</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">afp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">ja</span><span class="p">,</span> <span class="n">ia</span><span class="p">]</span>
            <span class="c1"># TODO check that we indeed have Hermiticity for non-collinear and spin-orbit</span>
            <span class="n">S</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">ja</span> <span class="o">+</span> <span class="n">afm</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">ja</span><span class="p">,</span> <span class="n">ia</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">S</span></div>

<div class="viewcode-block" id="SparseAtom.sub"><a class="viewcode-back" href="../../api-generated/sisl.SparseAtom.html#sisl.SparseAtom.sub">[docs]</a>    <span class="k">def</span> <span class="nf">sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a subset of this sparse matrix by only retaining the elements corresponding to the ``atom``</span>

<span class="sd">        Indices passed *MUST* be unique.</span>

<span class="sd">        Negative indices are wrapped and thus works.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : array_like of int</span>
<span class="sd">            indices of retained atoms</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Geometry.remove : the negative of `Geometry.sub`</span>
<span class="sd">        Geometry.sub : equivalent to the resulting `Geometry` from this routine</span>
<span class="sd">        remove : the negative of `sub`, i.e. remove a subset of atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span>
        <span class="c1"># Use broadcasting rules</span>
        <span class="n">idx</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">+=</span> <span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">idx</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>

        <span class="c1"># Now create the new sparse orbital class</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">S</span></div>

<div class="viewcode-block" id="SparseAtom.tile"><a class="viewcode-back" href="../../api-generated/sisl.SparseAtom.html#sisl.SparseAtom.tile">[docs]</a>    <span class="k">def</span> <span class="nf">tile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a tiled sparse atom object, equivalent to `Geometry.tile`</span>

<span class="sd">        The already existing sparse elements are extrapolated</span>
<span class="sd">        to the new supercell by repeating them in blocks like the coordinates.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Calling this routine will automatically `finalize` the `SparseAtom`. This</span>
<span class="sd">        is required to greatly increase performance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reps : int</span>
<span class="sd">            number of repetitions along cell-vector `axis`</span>
<span class="sd">        axis : int</span>
<span class="sd">            0, 1, 2 according to the cell-direction</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Geometry.tile: the same ordering as the final geometry</span>
<span class="sd">        Geometry.repeat: a different ordering of the final geometry</span>
<span class="sd">        repeat: a different ordering of the final geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create the new sparse object</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>

        <span class="c1"># Now begin to populate it accordingly</span>
        <span class="c1"># Retrieve local pointers to the information</span>
        <span class="c1"># regarding the current Hamiltonian sparse matrix</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>
        <span class="n">na</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">ncol</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span> <span class="ow">or</span> <span class="n">csr</span><span class="o">.</span><span class="n">nnz</span> <span class="o">==</span> <span class="n">csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">ptr</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">ncol</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">del</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">idx</span>

        <span class="c1"># Information for the new Hamiltonian sparse matrix</span>
        <span class="n">na_n</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
        <span class="n">geom_n</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">geom</span>

        <span class="c1"># First loop on axis tiling and local</span>
        <span class="c1"># atoms in the geometry</span>
        <span class="n">sc_index</span> <span class="o">=</span> <span class="n">geom_n</span><span class="o">.</span><span class="n">sc_index</span>

        <span class="c1"># Create new indptr, indices and D</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="n">ncol</span><span class="p">,</span> <span class="n">reps</span><span class="p">)</span>
        <span class="c1"># Now indptr is complete</span>
        <span class="n">indptr</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">cumsumi</span><span class="p">(</span><span class="n">ncol</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">ncol</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyi</span><span class="p">([</span><span class="n">indptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">indices</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Now we should fill the data</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">a2isc</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="c1"># resulting atom in the new geometry (without wrapping</span>
        <span class="c1"># for correct supercell, that will happen below)</span>
        <span class="n">JA</span> <span class="o">=</span> <span class="n">col</span> <span class="o">%</span> <span class="n">na</span> <span class="o">+</span> <span class="n">na</span> <span class="o">*</span> <span class="n">isc</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span>

        <span class="c1"># Create repetitions</span>
        <span class="k">for</span> <span class="n">rep</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reps</span><span class="p">):</span>
            <span class="c1"># Correct the supercell information</span>
            <span class="n">isc</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">JA</span> <span class="o">//</span> <span class="n">na_n</span>

            <span class="n">indices</span><span class="p">[</span><span class="n">rep</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">JA</span> <span class="o">%</span> <span class="n">na_n</span> <span class="o">+</span> <span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span> <span class="o">*</span> <span class="n">na_n</span>

            <span class="c1"># Step atoms</span>
            <span class="n">JA</span> <span class="o">+=</span> <span class="n">na</span>

        <span class="c1"># Clean-up</span>
        <span class="k">del</span> <span class="n">isc</span><span class="p">,</span> <span class="n">JA</span>

        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">SparseCSR</span><span class="p">((</span><span class="n">tile</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">indices</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">indptr</span><span class="p">),</span>
                           <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">geom_n</span><span class="o">.</span><span class="n">na</span><span class="p">,</span> <span class="n">geom_n</span><span class="o">.</span><span class="n">na_s</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">S</span></div>

<div class="viewcode-block" id="SparseAtom.repeat"><a class="viewcode-back" href="../../api-generated/sisl.SparseAtom.html#sisl.SparseAtom.repeat">[docs]</a>    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a repeated sparse atom object, equivalent to `Geometry.repeat`</span>

<span class="sd">        The already existing sparse elements are extrapolated</span>
<span class="sd">        to the new supercell by repeating them in blocks like the coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reps : int</span>
<span class="sd">            number of repetitions along cell-vector `axis`</span>
<span class="sd">        axis : int</span>
<span class="sd">            0, 1, 2 according to the cell-direction</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Geometry.repeat: the same ordering as the final geometry</span>
<span class="sd">        Geometry.tile: a different ordering of the final geometry</span>
<span class="sd">        tile: a different ordering of the final geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create the new sparse object</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>

        <span class="c1"># Now begin to populate it accordingly</span>
        <span class="c1"># Retrieve local pointers to the information</span>
        <span class="c1"># regarding the current Hamiltonian sparse matrix</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>
        <span class="n">na</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">ncol</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span> <span class="ow">or</span> <span class="n">csr</span><span class="o">.</span><span class="n">nnz</span> <span class="o">==</span> <span class="n">csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">ptr</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">ncol</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">del</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">idx</span>

        <span class="c1"># Information for the new Hamiltonian sparse matrix</span>
        <span class="n">na_n</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
        <span class="n">geom_n</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">geom</span>

        <span class="c1"># First loop on axis tiling and local</span>
        <span class="c1"># atoms in the geometry</span>
        <span class="n">sc_index</span> <span class="o">=</span> <span class="n">geom_n</span><span class="o">.</span><span class="n">sc_index</span>

        <span class="c1"># Create new indptr, indices and D</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">repeat</span><span class="p">(</span><span class="n">ncol</span><span class="p">,</span> <span class="n">reps</span><span class="p">)</span>
        <span class="c1"># Now indptr is complete</span>
        <span class="n">indptr</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">cumsumi</span><span class="p">(</span><span class="n">ncol</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">ncol</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyi</span><span class="p">([</span><span class="n">indptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

        <span class="c1"># Now we should fill the data</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">a2isc</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="c1"># resulting atom in the new geometry (without wrapping</span>
        <span class="c1"># for correct supercell, that will happen below)</span>
        <span class="n">JA</span> <span class="o">=</span> <span class="p">(</span><span class="n">col</span> <span class="o">%</span> <span class="n">na</span><span class="p">)</span> <span class="o">*</span> <span class="n">reps</span>
        <span class="c1"># Get the offset atoms</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">isc</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">rep</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reps</span><span class="p">):</span>

            <span class="c1"># Update the offset</span>
            <span class="n">A</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Correct supercell information</span>
            <span class="n">isc</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span> <span class="o">//</span> <span class="n">reps</span>

            <span class="c1"># Create the indices for the repetition</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">indptr</span><span class="p">[</span><span class="n">rep</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">reps</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">)</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">JA</span> <span class="o">+</span> <span class="n">A</span> <span class="o">%</span> <span class="n">reps</span> <span class="o">+</span> <span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span> <span class="o">*</span> <span class="n">na_n</span>

        <span class="c1"># Clean-up</span>
        <span class="k">del</span> <span class="n">isc</span><span class="p">,</span> <span class="n">JA</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">idx</span>

        <span class="c1"># In the repeat we have to tile individual atomic couplings</span>
        <span class="c1"># So we should split the arrays and tile them individually</span>
        <span class="c1"># Now D is made up of D values, per atom</span>
        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ntile</span> <span class="o">=</span> <span class="n">ftool</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">ntile</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">_a</span><span class="o">.</span><span class="n">cumsumi</span><span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))))</span>

        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">SparseCSR</span><span class="p">((</span><span class="n">D</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indptr</span><span class="p">),</span>
                           <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">geom_n</span><span class="o">.</span><span class="n">na</span><span class="p">,</span> <span class="n">geom_n</span><span class="o">.</span><span class="n">na_s</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">S</span></div>

<div class="viewcode-block" id="SparseAtom.rij"><a class="viewcode-back" href="../../api-generated/sisl.SparseAtom.html#sisl.SparseAtom.rij">[docs]</a>    <span class="k">def</span> <span class="nf">rij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Create a sparse matrix with the distance between atoms</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : numpy.dtype, optional</span>
<span class="sd">            the data-type of the sparse matrix.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The returned sparse matrix with distances are taken from the current sparse pattern.</span>
<span class="sd">        I.e. a subsequent addition of sparse elements will make them inequivalent.</span>
<span class="sd">        It is thus important to *only* create the sparse distance when the sparse</span>
<span class="sd">        structure is completed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rij</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">R</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">_csr</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="k">return</span> <span class="n">R</span></div>

<div class="viewcode-block" id="SparseAtom.Rij"><a class="viewcode-back" href="../../api-generated/sisl.SparseAtom.html#sisl.SparseAtom.Rij">[docs]</a>    <span class="k">def</span> <span class="nf">Rij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Create a sparse matrix with the vectors between atoms</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : numpy.dtype, optional</span>
<span class="sd">            the data-type of the sparse matrix.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The returned sparse matrix with vectors are taken from the current sparse pattern.</span>
<span class="sd">        I.e. a subsequent addition of sparse elements will make them inequivalent.</span>
<span class="sd">        It is thus important to *only* create the sparse vector matrix when the sparse</span>
<span class="sd">        structure is completed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>
        <span class="n">Rij</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">Rij</span>

        <span class="c1"># Pointers</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span>

        <span class="c1"># Create the output class</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">SparseAtom</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Re-create the sparse matrix data</span>
        <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">nnz</span>
        <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span>
        <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="n">ia</span><span class="p">],</span> <span class="n">ptr</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span> <span class="o">+</span> <span class="n">ncol</span><span class="p">[</span><span class="n">ia</span><span class="p">])</span>
            <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Rij</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">col</span><span class="p">[</span><span class="n">sl</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">R</span></div></div>


<div class="viewcode-block" id="SparseOrbital"><a class="viewcode-back" href="../../api-generated/sisl.SparseOrbital.html#sisl.SparseOrbital">[docs]</a><span class="k">class</span> <span class="nc">SparseOrbital</span><span class="p">(</span><span class="n">_SparseGeometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Sparse object with number of rows equal to the total number of orbitals in the `Geometry` &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Elements for the index(s) &quot;&quot;&quot;</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># This may be a specification of supercell indices</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="c1"># We guess it is the supercell index</span>
                <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">key</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">osc2uc</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">off</span>
        <span class="k">if</span> <span class="n">dd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">dd</span><span class="p">,)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set or create elements in the sparse data</span>

<span class="sd">        Override set item for slicing operations and enables easy</span>
<span class="sd">        setting of parameters in a sparse matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># This may be a specification of supercell indices</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="c1"># We guess it is the supercell index</span>
                <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">key</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">osc2uc</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">off</span>
        <span class="k">if</span> <span class="n">dd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">dd</span><span class="p">,)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span>

<div class="viewcode-block" id="SparseOrbital.edges"><a class="viewcode-back" href="../../api-generated/sisl.SparseOrbital.html#sisl.SparseOrbital.edges">[docs]</a>    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">orbital</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Retrieve edges (connections) of a given `atom` or list of `atom`&#39;s</span>

<span class="sd">        The returned edges are unique and sorted (see `numpy.unique`) and are returned</span>
<span class="sd">        in supercell indices (i.e. ``0 &lt;= edge &lt; self.geometry.no_s``).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : int or list of int</span>
<span class="sd">            the edges are returned only for the given atom (but by using  all orbitals of the</span>
<span class="sd">            requested atom). The returned edges are also atoms.</span>
<span class="sd">        exclude : int or list of int, optional</span>
<span class="sd">           remove edges which are in the `exclude` list.</span>
<span class="sd">           Default to `atom`.</span>
<span class="sd">        orbital : int or list of int</span>
<span class="sd">            the edges are returned only for the given orbital. The returned edges are orbitals.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        SparseCSR.edges: the underlying routine used for extracting the edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">orbital</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.edges must have either &quot;atom&quot; or &quot;orbital&quot; keyword defined.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">orbital</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">exclude</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">orbital</span><span class="p">,</span> <span class="n">exclude</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseOrbital.nonzero"><a class="viewcode-back" href="../../api-generated/sisl.SparseOrbital.html#sisl.SparseOrbital.nonzero">[docs]</a>    <span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">only_col</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Indices row and column indices where non-zero elements exists</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : int or array_like of int, optional</span>
<span class="sd">           only return the tuples for the requested atoms, default is all atoms</span>
<span class="sd">           But for *all* orbitals.</span>
<span class="sd">        only_col : bool, optional</span>
<span class="sd">           only return then non-zero columns</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        SparseCSR.nonzero : the equivalent function call</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">only_col</span><span class="o">=</span><span class="n">only_col</span><span class="p">)</span>
        <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">row</span><span class="o">=</span><span class="n">row</span><span class="p">,</span> <span class="n">only_col</span><span class="o">=</span><span class="n">only_col</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseOrbital.iter_nnz"><a class="viewcode-back" href="../../api-generated/sisl.SparseOrbital.html#sisl.SparseOrbital.iter_nnz">[docs]</a>    <span class="k">def</span> <span class="nf">iter_nnz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">orbital</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Iterations of the non-zero elements</span>

<span class="sd">        An iterator on the sparse matrix with, row and column</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; for i, j in self.iter_nnz():</span>
<span class="sd">        ...    self[i, j] # is then the non-zero value</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : int or array_like</span>
<span class="sd">            only loop on the non-zero elements coinciding with the orbitals</span>
<span class="sd">            on these atoms (not compatible with the ``orbital`` keyword)</span>
<span class="sd">        orbital : int or array_like</span>
<span class="sd">            only loop on the non-zero elements coinciding with the orbital</span>
<span class="sd">            (not compatible with the ``atom`` keyword)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">orbital</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">orbital</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">orbital</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">orbital</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">orbital</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">iter_nnz</span><span class="p">(</span><span class="n">orbital</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">iter_nnz</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span></div>

<div class="viewcode-block" id="SparseOrbital.set_nsc"><a class="viewcode-back" href="../../api-generated/sisl.SparseOrbital.html#sisl.SparseOrbital.set_nsc">[docs]</a>    <span class="k">def</span> <span class="nf">set_nsc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reset the number of allowed supercells in the sparse orbital</span>

<span class="sd">        If one reduces the number of supercells *any* sparse element</span>
<span class="sd">        that references the supercell will be deleted.</span>

<span class="sd">        See `SuperCell.set_nsc` for allowed parameters.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        SuperCell.set_nsc : the underlying called method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SparseOrbital</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseOrbital.cut"><a class="viewcode-back" href="../../api-generated/sisl.SparseOrbital.html#sisl.SparseOrbital.cut">[docs]</a>    <span class="k">def</span> <span class="nf">cut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seps</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Cuts the sparse orbital model into different parts.</span>

<span class="sd">        Recreates a new sparse orbital object with only the cutted</span>
<span class="sd">        atoms in the structure.</span>

<span class="sd">        Cutting is the opposite of tiling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        seps : int</span>
<span class="sd">           number of times the structure will be cut</span>
<span class="sd">        axis : int</span>
<span class="sd">           the axis that will be cut</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_w</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Create new geometry</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
            <span class="c1"># Cause all warnings to always be triggered.</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;always&quot;</span><span class="p">)</span>
            <span class="c1"># Create new cut geometry</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">seps</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># Check whether the warning exists</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">category</span><span class="p">,</span> <span class="n">SislWarning</span><span class="p">):</span>
                    <span class="n">new_w</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
                    <span class="n">new_w</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">---</span><span class="se">\n</span><span class="s2">&quot;</span>
                              <span class="s2">&quot;The sparse orbital cannot be cut as the structure &quot;</span>
                              <span class="s2">&quot;cannot be tiled accordingly. ANY use of the model has been &quot;</span>
                              <span class="s2">&quot;relieved from sisl.&quot;</span><span class="p">)</span>
                    <span class="n">warn</span><span class="p">(</span><span class="n">new_w</span><span class="p">)</span>

        <span class="c1"># Now we need to re-create number of supercells</span>
        <span class="n">no</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tocsr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># First we need to figure out how long the interaction range is</span>
        <span class="c1"># in the cut-direction</span>
        <span class="c1"># We initialize to be the same as the parent direction</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsc</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># we count the new direction</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosi</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">out</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">out</span><span class="p">:</span>
            <span class="c1"># Get supercell index</span>
            <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">sub</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">,</span> <span class="n">idx</span> <span class="o">*</span> <span class="n">no</span><span class="p">:(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">no</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">[:]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">c_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span>
            <span class="c1"># Count the number of cells it interacts with</span>
            <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_max</span> <span class="o">%</span> <span class="n">no</span><span class="p">)</span> <span class="o">//</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span>
            <span class="n">ic</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">*</span> <span class="n">no</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">ic</span> <span class="o">+</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span> <span class="o">*</span> <span class="n">j</span>
                <span class="c1"># We need to ensure that every &quot;in between&quot; index exists</span>
                <span class="c1"># if it does not we discard those indices</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">sub</span><span class="p">,</span>
                                      <span class="n">sub</span> <span class="o">&lt;</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
            <span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">*</span> <span class="n">seps</span> <span class="o">+</span> <span class="n">i</span>

            <span class="k">if</span> <span class="n">out</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Cut the connection at nsc=</span><span class="si">{0}</span><span class="s1"> in direction </span><span class="si">{1}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">axis</span><span class="p">))</span>

        <span class="c1"># Update number of super-cells</span>
        <span class="n">nsc</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">nsc</span><span class="p">[:]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">geom</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">nsc</span><span class="p">)</span>

        <span class="c1"># Now we have a correct geometry, and</span>
        <span class="c1"># we are now ready to create the sparsity pattern</span>
        <span class="c1"># Reduce the sparsity pattern, first create the new one</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>

        <span class="k">def</span> <span class="nf">_sco2sco</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">seps</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
            <span class="c1"># Converts an o from M to m</span>
            <span class="n">isc</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">o2isc</span><span class="p">(</span><span class="n">o</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">*</span> <span class="n">seps</span>
            <span class="c1"># Correct for cell-offset</span>
            <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">o</span> <span class="o">%</span> <span class="n">M</span><span class="o">.</span><span class="n">no</span><span class="p">)</span> <span class="o">//</span> <span class="n">m</span><span class="o">.</span><span class="n">no</span>
            <span class="c1"># find the equivalent cell in m</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># If a fail happens it is due to a discarded</span>
                <span class="c1"># interaction across a non-interacting region</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">o</span> <span class="o">%</span> <span class="n">m</span><span class="o">.</span><span class="n">no</span><span class="p">,</span>
                        <span class="n">m</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="o">.</span><span class="n">no</span><span class="p">,</span>
                        <span class="n">m</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="o">-</span><span class="n">isc</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># only loop on the orbitals remaining in the cutted structure</span>
        <span class="k">for</span> <span class="n">jo</span><span class="p">,</span> <span class="n">io</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_nnz</span><span class="p">(</span><span class="n">orbital</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">)):</span>

            <span class="c1"># Get the equivalent orbital in the smaller cell</span>
            <span class="n">o</span><span class="p">,</span> <span class="n">ofp</span><span class="p">,</span> <span class="n">ofm</span> <span class="o">=</span> <span class="n">_sco2sco</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">geom</span><span class="p">,</span> <span class="n">seps</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">o</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">jo</span><span class="p">,</span> <span class="n">io</span><span class="p">]</span>
            <span class="n">S</span><span class="p">[</span><span class="n">jo</span><span class="p">,</span> <span class="n">o</span> <span class="o">+</span> <span class="n">ofp</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
            <span class="n">S</span><span class="p">[</span><span class="n">o</span><span class="p">,</span> <span class="n">jo</span> <span class="o">+</span> <span class="n">ofm</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>

        <span class="k">return</span> <span class="n">S</span></div>

<div class="viewcode-block" id="SparseOrbital.remove"><a class="viewcode-back" href="../../api-generated/sisl.SparseOrbital.html#sisl.SparseOrbital.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">orb_index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Remove a subset of this sparse matrix by only retaining the atoms corresponding to `atom`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : array_like of int or Atom</span>
<span class="sd">            indices of removed atoms or Atom for direct removal of all atoms</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Geometry.remove : equivalent to the resulting `Geometry` from this routine</span>
<span class="sd">        Geometry.sub : the negative of `Geometry.remove`</span>
<span class="sd">        sub : the opposite of `remove`, i.e. retain a subset of atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">Atom</span><span class="p">):</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">specie</span> <span class="o">==</span> <span class="n">atom</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># This will digress to call .sub</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SparseOrbital</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseOrbital.remove_orbital"><a class="viewcode-back" href="../../api-generated/sisl.SparseOrbital.html#sisl.SparseOrbital.remove_orbital">[docs]</a>    <span class="k">def</span> <span class="nf">remove_orbital</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">orbital</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Remove a subset of orbitals on `atom` according to `orbital`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : array_like of int or Atom</span>
<span class="sd">            indices of atoms or `Atom` that will be reduced in size according to `orbital`</span>
<span class="sd">        orbital : array_like of int or Orbital</span>
<span class="sd">            indices of the orbitals on `atom` that are removed from the sparse matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; obj = SparseOrbital(...)</span>
<span class="sd">        &gt;&gt;&gt; # remove the second orbital on the 2nd atom</span>
<span class="sd">        &gt;&gt;&gt; # all other orbitals are retained</span>
<span class="sd">        &gt;&gt;&gt; obj.remove_orbital(1, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get specie index of the atom</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">Atom</span><span class="p">):</span>
            <span class="c1"># All atoms with this specie</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">specie</span> <span class="o">==</span> <span class="n">atom</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Figure out if all atoms have the same species</span>
        <span class="n">specie</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">specie</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span>
        <span class="n">uniq_specie</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">specie</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uniq_specie</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># In case there are multiple different species but one wishes to</span>
            <span class="c1"># retain the same orbital index, then we loop on the unique species</span>
            <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">uniq_specie</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">remove_orbital</span><span class="p">(</span><span class="n">atom</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">orbital</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new</span>

        <span class="c1"># Get the atom object we wish to reduce</span>
        <span class="c1"># We know np.all(geom.atoms[atom] == old_atom)</span>
        <span class="n">old_atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atom</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="c1"># Retrieve index of orbital</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orbital</span><span class="p">,</span> <span class="n">Orbital</span><span class="p">):</span>
            <span class="n">orbital</span> <span class="o">=</span> <span class="n">old_atom</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">orbital</span><span class="p">)</span>
        <span class="c1"># Create the reverse index-table to delete those not required</span>
        <span class="n">orbital</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">old_atom</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">orbital</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">orbital</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseOrbital.sub"><a class="viewcode-back" href="../../api-generated/sisl.SparseOrbital.html#sisl.SparseOrbital.sub">[docs]</a>    <span class="k">def</span> <span class="nf">sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a subset of this sparse matrix by only retaining the atoms corresponding to `atom`</span>

<span class="sd">        Negative indices are wrapped and thus works, supercell atoms are also wrapped to the unit-cell.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : array_like of int or Atom</span>
<span class="sd">            indices of retained atoms or `Atom` for retaining only *that* atom</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; obj = SparseOrbital(...)</span>
<span class="sd">        &gt;&gt;&gt; obj.sub(1) # only retain the second atom in the SparseGeometry</span>
<span class="sd">        &gt;&gt;&gt; obj.sub(obj.atoms.atom[0]) # retain all atoms which is equivalent to</span>
<span class="sd">        &gt;&gt;&gt;                            # the first atomic specie</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Geometry.remove : the negative of `Geometry.sub`</span>
<span class="sd">        Geometry.sub : equivalent to the resulting `Geometry` from this routine</span>
<span class="sd">        remove : the negative of `sub`, i.e. remove a subset of atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">Atom</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">specie</span> <span class="o">==</span> <span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
        <span class="n">orbs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="n">orbs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span>
        <span class="c1"># Use broadcasting rules</span>
        <span class="n">idx</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">+=</span> <span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">idx</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>

        <span class="c1"># Now create the new sparse orbital class</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">S</span></div>

<div class="viewcode-block" id="SparseOrbital.sub_orbital"><a class="viewcode-back" href="../../api-generated/sisl.SparseOrbital.html#sisl.SparseOrbital.sub_orbital">[docs]</a>    <span class="k">def</span> <span class="nf">sub_orbital</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">orbital</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Retain only a subset of the orbitals on `atom` according to `orbital`</span>

<span class="sd">        This allows one to retain only a given subset of the sparse matrix elements. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : array_like of int or Atom</span>
<span class="sd">            indices of atoms or `Atom` that will be reduced in size according to `orbital`</span>
<span class="sd">        orbital : array_like of int or Orbital</span>
<span class="sd">            indices of the orbitals on `atom` that are retained in the sparse matrix, the list of</span>
<span class="sd">            orbitals will be sorted. One cannot re-arrange matrix elements currently.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Future implementations may allow one to re-arange orbitals using this method.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; obj = SparseOrbital(...)</span>
<span class="sd">        &gt;&gt;&gt; # only retain the second orbital on the 2nd atom</span>
<span class="sd">        &gt;&gt;&gt; # all other orbitals are retained</span>
<span class="sd">        &gt;&gt;&gt; obj.sub_orbital(1, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get specie index of the atom</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">Atom</span><span class="p">):</span>
            <span class="c1"># All atoms with this specie</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">specie</span> <span class="o">==</span> <span class="n">atom</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Figure out if all atoms have the same species</span>
        <span class="n">specie</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">specie</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span>
        <span class="n">uniq_specie</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">specie</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uniq_specie</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># In case there are multiple different species but one wishes to</span>
            <span class="c1"># retain the same orbital index, then we loop on the unique species</span>
            <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">uniq_specie</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">(</span><span class="n">atom</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">orbital</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new</span>

        <span class="c1"># At this point we are sure that uniq_specie is *only* one specie!</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Get the atom object we wish to reduce</span>
        <span class="n">old_atom</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atom</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="c1"># Retrieve index of orbital</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orbital</span><span class="p">,</span> <span class="n">Orbital</span><span class="p">):</span>
            <span class="n">orbital</span> <span class="o">=</span> <span class="n">old_atom</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">orbital</span><span class="p">)</span>
        <span class="n">orbital</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">orbital</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbital</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;trying to retain 0 orbitals on a given atom. This is not allowed!&#39;</span><span class="p">)</span>

        <span class="n">new_atom</span> <span class="o">=</span> <span class="n">old_atom</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">orbital</span><span class="p">)</span>
        <span class="c1"># Rename the new-atom to &lt;&gt;_1_2 for orbital == [1, 2]</span>
        <span class="n">new_atom</span><span class="o">.</span><span class="n">tag</span> <span class="o">+=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">orbital</span><span class="p">))</span>

        <span class="c1"># We catch the warning about reducing the number of orbitals!</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
            <span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">replace_atom</span><span class="p">(</span><span class="n">old_atom</span><span class="p">,</span> <span class="n">new_atom</span><span class="p">)</span>

        <span class="c1"># Now create the new sparse orbital class</span>
        <span class="n">SG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>

        <span class="n">rem_orbs</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">old_atom</span><span class="o">.</span><span class="n">no</span><span class="p">),</span> <span class="n">orbital</span><span class="p">)</span>
        <span class="c1"># Find orbitals to remove (note this HAS to be from the original array)</span>
        <span class="n">rem_orbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atom</span><span class="p">),</span> <span class="n">rem_orbs</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Generate a list of orbitals to retain</span>
        <span class="n">sub_idx</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">),</span> <span class="n">rem_orbs</span><span class="p">)</span>

        <span class="c1"># Generate full supercell indices</span>
        <span class="n">n_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">n_s</span>
        <span class="n">sc_off</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">n_s</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
        <span class="n">sub_idx</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="n">sub_idx</span><span class="p">,</span> <span class="n">n_s</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_s</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">sc_off</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">SG</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">sub_idx</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">SG</span></div>

<div class="viewcode-block" id="SparseOrbital.tile"><a class="viewcode-back" href="../../api-generated/sisl.SparseOrbital.html#sisl.SparseOrbital.tile">[docs]</a>    <span class="k">def</span> <span class="nf">tile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a tiled sparse orbital object, equivalent to `Geometry.tile`</span>

<span class="sd">        The already existing sparse elements are extrapolated</span>
<span class="sd">        to the new supercell by repeating them in blocks like the coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reps : int</span>
<span class="sd">            number of repetitions along cell-vector `axis`</span>
<span class="sd">        axis : int</span>
<span class="sd">            0, 1, 2 according to the cell-direction</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Geometry.tile: the same ordering as the final geometry</span>
<span class="sd">        Geometry.repeat: a different ordering of the final geometry</span>
<span class="sd">        repeat: a different ordering of the final geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create the new sparse object</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>

        <span class="c1"># Now begin to populate it accordingly</span>
        <span class="c1"># Retrieve local pointers to the information</span>
        <span class="c1"># regarding the current Hamiltonian sparse matrix</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>
        <span class="n">no</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">ncol</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span> <span class="ow">or</span> <span class="n">csr</span><span class="o">.</span><span class="n">nnz</span> <span class="o">==</span> <span class="n">csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">ptr</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">ncol</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">del</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">idx</span>

        <span class="c1"># Information for the new Hamiltonian sparse matrix</span>
        <span class="n">no_n</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="n">geom_n</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">geom</span>

        <span class="c1"># First loop on axis tiling and local</span>
        <span class="c1"># atoms in the geometry</span>
        <span class="n">sc_index</span> <span class="o">=</span> <span class="n">geom_n</span><span class="o">.</span><span class="n">sc_index</span>

        <span class="c1"># Create new indptr, indices and D</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="n">ncol</span><span class="p">,</span> <span class="n">reps</span><span class="p">)</span>
        <span class="c1"># Now indptr is complete</span>
        <span class="n">indptr</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">cumsumi</span><span class="p">(</span><span class="n">ncol</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">ncol</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyi</span><span class="p">([</span><span class="n">indptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">indices</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Now we should fill the data</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">o2isc</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="c1"># resulting atom in the new geometry (without wrapping</span>
        <span class="c1"># for correct supercell, that will happen below)</span>
        <span class="n">JO</span> <span class="o">=</span> <span class="n">col</span> <span class="o">%</span> <span class="n">no</span> <span class="o">+</span> <span class="n">no</span> <span class="o">*</span> <span class="n">isc</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span>

        <span class="c1"># Create repetitions</span>
        <span class="k">for</span> <span class="n">rep</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reps</span><span class="p">):</span>
            <span class="c1"># Correct the supercell information</span>
            <span class="n">isc</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">JO</span> <span class="o">//</span> <span class="n">no_n</span>

            <span class="n">indices</span><span class="p">[</span><span class="n">rep</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">JO</span> <span class="o">%</span> <span class="n">no_n</span> <span class="o">+</span> <span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span> <span class="o">*</span> <span class="n">no_n</span>

            <span class="c1"># Step orbitals</span>
            <span class="n">JO</span> <span class="o">+=</span> <span class="n">no</span>

        <span class="c1"># Clean-up</span>
        <span class="k">del</span> <span class="n">isc</span><span class="p">,</span> <span class="n">JO</span>

        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">SparseCSR</span><span class="p">((</span><span class="n">tile</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">indices</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">indptr</span><span class="p">),</span>
                           <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">geom_n</span><span class="o">.</span><span class="n">no</span><span class="p">,</span> <span class="n">geom_n</span><span class="o">.</span><span class="n">no_s</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">S</span></div>

<div class="viewcode-block" id="SparseOrbital.repeat"><a class="viewcode-back" href="../../api-generated/sisl.SparseOrbital.html#sisl.SparseOrbital.repeat">[docs]</a>    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a repeated sparse orbital object, equivalent to `Geometry.repeat`</span>

<span class="sd">        The already existing sparse elements are extrapolated</span>
<span class="sd">        to the new supercell by repeating them in blocks like the coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reps : int</span>
<span class="sd">            number of repetitions along cell-vector `axis`</span>
<span class="sd">        axis : int</span>
<span class="sd">            0, 1, 2 according to the cell-direction</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Geometry.repeat: the same ordering as the final geometry</span>
<span class="sd">        Geometry.tile: a different ordering of the final geometry</span>
<span class="sd">        tile: a different ordering of the final geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create the new sparse object</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>

        <span class="c1"># Now begin to populate it accordingly</span>
        <span class="c1"># Retrieve local pointers to the information</span>
        <span class="c1"># regarding the current Hamiltonian sparse matrix</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>
        <span class="n">no</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">ncol</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span> <span class="ow">or</span> <span class="n">csr</span><span class="o">.</span><span class="n">nnz</span> <span class="o">==</span> <span class="n">csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">ptr</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">ncol</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">del</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">idx</span>

        <span class="c1"># Information for the new Hamiltonian sparse matrix</span>
        <span class="n">no_n</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="n">geom_n</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">geom</span>

        <span class="c1"># First loop on axis tiling and local</span>
        <span class="c1"># orbitals in the geometry</span>
        <span class="n">sc_index</span> <span class="o">=</span> <span class="n">geom_n</span><span class="o">.</span><span class="n">sc_index</span>

        <span class="c1"># Create new indptr, indices and D</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">repeat</span><span class="p">(</span><span class="n">ncol</span><span class="p">,</span> <span class="n">reps</span><span class="p">)</span>
        <span class="c1"># Now indptr is complete</span>
        <span class="n">indptr</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">cumsumi</span><span class="p">(</span><span class="n">ncol</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">ncol</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyi</span><span class="p">([</span><span class="n">indptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

        <span class="c1"># Now we should fill the data</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">o2isc</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="c1"># resulting orbital in the new geometry (without wrapping</span>
        <span class="c1"># for correct supercell, that will happen below)</span>
        <span class="n">JO</span> <span class="o">=</span> <span class="n">col</span> <span class="o">%</span> <span class="n">no</span>
        <span class="c1"># Get number of orbitals per atom (lasto - firsto + 1)</span>
        <span class="c1"># This is faster than the direct call</span>

        <span class="n">ja</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">JO</span><span class="p">)</span>
        <span class="n">oJ</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">ja</span><span class="p">]</span>
        <span class="n">oA</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">lasto</span><span class="p">[</span><span class="n">ja</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">oJ</span>
        <span class="c1"># Shift the orbitals corresponding to the</span>
        <span class="c1"># repetitions of all previous atoms</span>
        <span class="n">JO</span> <span class="o">+=</span> <span class="n">oJ</span> <span class="o">*</span> <span class="p">(</span><span class="n">reps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Get the offset orbitals</span>
        <span class="n">O</span> <span class="o">=</span> <span class="n">isc</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># We need to create and indexable atomic array</span>
        <span class="c1"># This is required for multi-orbital cases where</span>
        <span class="c1"># we should tile atomic orbitals, and repeat the atoms (only).</span>
        <span class="c1"># &#39;A&#39; is now the first (non-repeated) atom in the new structure</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">na</span><span class="p">)</span> <span class="o">*</span> <span class="n">reps</span>
        <span class="n">AO</span> <span class="o">=</span> <span class="n">geom_n</span><span class="o">.</span><span class="n">lasto</span><span class="p">[</span><span class="n">A</span><span class="p">]</span> <span class="o">-</span> <span class="n">geom_n</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">A</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># subtract AO for first iteration in repetition loop</span>
        <span class="n">OA</span> <span class="o">=</span> <span class="n">geom_n</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">A</span><span class="p">]</span> <span class="o">-</span> <span class="n">AO</span>

        <span class="c1"># Clean</span>
        <span class="k">del</span> <span class="n">ja</span><span class="p">,</span> <span class="n">oJ</span><span class="p">,</span> <span class="n">A</span>

        <span class="c1"># Get view of ncol</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span>

        <span class="c1"># Create repetitions</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reps</span><span class="p">):</span>

            <span class="c1"># Update atomic offset</span>
            <span class="n">OA</span> <span class="o">+=</span> <span class="n">AO</span>
            <span class="c1"># Update the offset</span>
            <span class="n">O</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Correct supercell information</span>
            <span class="n">isc</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">O</span> <span class="o">//</span> <span class="n">reps</span>

            <span class="c1"># Create the indices for the repetition</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">indptr</span><span class="p">[</span><span class="n">array_arange</span><span class="p">(</span><span class="n">OA</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">AO</span><span class="p">)],</span> <span class="n">n</span><span class="o">=</span><span class="n">ncol</span><span class="p">)</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">JO</span> <span class="o">+</span> <span class="n">oA</span> <span class="o">*</span> <span class="p">(</span><span class="n">O</span> <span class="o">%</span> <span class="n">reps</span><span class="p">)</span> <span class="o">+</span> <span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span> <span class="o">*</span> <span class="n">no_n</span>

        <span class="c1"># Clean-up</span>
        <span class="k">del</span> <span class="n">isc</span><span class="p">,</span> <span class="n">JO</span><span class="p">,</span> <span class="n">O</span><span class="p">,</span> <span class="n">OA</span><span class="p">,</span> <span class="n">AO</span><span class="p">,</span> <span class="n">idx</span>

        <span class="c1"># In the repeat we have to tile individual atomic couplings</span>
        <span class="c1"># So we should split the arrays and tile them individually</span>
        <span class="c1"># Now D is made up of D values, per atom</span>
        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ntile</span> <span class="o">=</span> <span class="n">ftool</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">ntile</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">_a</span><span class="o">.</span><span class="n">cumsumi</span><span class="p">(</span><span class="n">ncol</span><span class="p">)[</span><span class="n">geom</span><span class="o">.</span><span class="n">lasto</span><span class="p">[:</span><span class="n">geom</span><span class="o">.</span><span class="n">na</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))))</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">SparseCSR</span><span class="p">((</span><span class="n">D</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indptr</span><span class="p">),</span>
                           <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">geom_n</span><span class="o">.</span><span class="n">no</span><span class="p">,</span> <span class="n">geom_n</span><span class="o">.</span><span class="n">no_s</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">S</span></div>

<div class="viewcode-block" id="SparseOrbital.rij"><a class="viewcode-back" href="../../api-generated/sisl.SparseOrbital.html#sisl.SparseOrbital.rij">[docs]</a>    <span class="k">def</span> <span class="nf">rij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="s1">&#39;orbital&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Create a sparse matrix with the distance between atoms/orbitals</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        what : {&#39;orbital&#39;, &#39;atom&#39;}</span>
<span class="sd">            which kind of sparse distance matrix to return, either an atomic distance matrix</span>
<span class="sd">            or an orbital distance matrix. The orbital matrix is equivalent to the atomic</span>
<span class="sd">            one with the same distance repeated for the same atomic orbitals.</span>
<span class="sd">            The default is the same type as the parent class.</span>
<span class="sd">        dtype : numpy.dtype, optional</span>
<span class="sd">            the data-type of the sparse matrix.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The returned sparse matrix with distances are taken from the current sparse pattern.</span>
<span class="sd">        I.e. a subsequent addition of sparse elements will make them inequivalent.</span>
<span class="sd">        It is thus important to *only* create the sparse distance when the sparse</span>
<span class="sd">        structure is completed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rij</span><span class="p">(</span><span class="n">what</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="n">R</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">_csr</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="k">return</span> <span class="n">R</span></div>

<div class="viewcode-block" id="SparseOrbital.Rij"><a class="viewcode-back" href="../../api-generated/sisl.SparseOrbital.html#sisl.SparseOrbital.Rij">[docs]</a>    <span class="k">def</span> <span class="nf">Rij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="s1">&#39;orbital&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Create a sparse matrix with the vectors between atoms/orbitals</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        what : {&#39;orbital&#39;, &#39;atom&#39;}</span>
<span class="sd">            which kind of sparse vector matrix to return, either an atomic vector matrix</span>
<span class="sd">            or an orbital vector matrix. The orbital matrix is equivalent to the atomic</span>
<span class="sd">            one with the same vectors repeated for the same atomic orbitals.</span>
<span class="sd">            The default is the same type as the parent class.</span>
<span class="sd">        dtype : numpy.dtype, optional</span>
<span class="sd">            the data-type of the sparse matrix.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The returned sparse matrix with vectors are taken from the current sparse pattern.</span>
<span class="sd">        I.e. a subsequent addition of sparse elements will make them inequivalent.</span>
<span class="sd">        It is thus important to *only* create the sparse vector matrix when the sparse</span>
<span class="sd">        structure is completed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>

        <span class="c1"># Pointers</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span>

        <span class="k">if</span> <span class="n">what</span> <span class="o">==</span> <span class="s1">&#39;atom&#39;</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">SparseAtom</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">ncol</span><span class="p">))</span>
            <span class="n">Rij</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">Rij</span>
            <span class="n">o2a</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">o2a</span>

            <span class="c1"># Orbitals</span>
            <span class="n">orow</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># Loop on orbitals and atoms</span>
            <span class="k">for</span> <span class="n">io</span><span class="p">,</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">orow</span><span class="p">,</span> <span class="n">o2a</span><span class="p">(</span><span class="n">orow</span><span class="p">)):</span>
                <span class="n">coln</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">o2a</span><span class="p">(</span><span class="n">col</span><span class="p">[</span><span class="n">ptr</span><span class="p">[</span><span class="n">io</span><span class="p">]:</span><span class="n">ptr</span><span class="p">[</span><span class="n">io</span><span class="p">]</span><span class="o">+</span><span class="n">ncol</span><span class="p">[</span><span class="n">io</span><span class="p">]]))</span>
                <span class="n">R</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="n">coln</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rij</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">coln</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">what</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;orbital&#39;</span><span class="p">,</span> <span class="s1">&#39;orb&#39;</span><span class="p">]:</span>
            <span class="c1"># We create an *exact* copy of the Rij</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">SparseOrbital</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">Rij</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">oRij</span>

            <span class="c1"># Re-create the sparse matrix data</span>
            <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">nnz</span>
            <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span>

            <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="n">io</span><span class="p">],</span> <span class="n">ptr</span><span class="p">[</span><span class="n">io</span><span class="p">]</span> <span class="o">+</span> <span class="n">ncol</span><span class="p">[</span><span class="n">io</span><span class="p">])</span>
                <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Rij</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">col</span><span class="p">[</span><span class="n">sl</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.Rij &quot;what&quot; is not one of [atom, orbital].&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">R</span></div>

<div class="viewcode-block" id="SparseOrbital.prepend"><a class="viewcode-back" href="../../api-generated/sisl.SparseOrbital.html#sisl.SparseOrbital.prepend">[docs]</a>    <span class="k">def</span> <span class="nf">prepend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; See `append` for details</span>

<span class="sd">        This is currently equivalent to:</span>

<span class="sd">        &gt;&gt;&gt; other.append(self, axis, eps)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseOrbital.append"><a class="viewcode-back" href="../../api-generated/sisl.SparseOrbital.html#sisl.SparseOrbital.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Append `other` along `axis` to construct a new connected sparse matrix</span>

<span class="sd">        This method tries to append two sparse geometry objects together by</span>
<span class="sd">        the following these steps:</span>

<span class="sd">        1. Create the new extended geometry</span>
<span class="sd">        2. Use neighbor cell couplings from `self` as the couplings to `other`</span>
<span class="sd">           This *may* cause problems if the coupling atoms are not exactly equi-positioned.</span>
<span class="sd">           If the coupling coordinates and the coordinates in `other` differ by more than</span>
<span class="sd">           0.001 Ang, a warning will be issued.</span>
<span class="sd">           If this difference is above `eps` the couplings will be removed.</span>

<span class="sd">        When appending sparse matrices made up of atoms, this method assumes that</span>
<span class="sd">        the orbitals on the overlapping atoms have the same orbitals, as well as the</span>
<span class="sd">        same orbital ordering.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; sporb = SparseOrbital(....)</span>
<span class="sd">        &gt;&gt;&gt; forced_hermitian = (sporb + sporb.transpose()) * 0.5</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This routine and how it is functioning may change in future releases.</span>
<span class="sd">        There are many design choices in how to assign the matrix elements when</span>
<span class="sd">        combining two models and it is not clear what is the best procedure.</span>

<span class="sd">        The current implentation does not preserve the hermiticity of the matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : object</span>
<span class="sd">            must be an object of the same type as `self`</span>
<span class="sd">        axis : int</span>
<span class="sd">            axis to append the two sparse geometries along</span>
<span class="sd">        eps : float, optional</span>
<span class="sd">            tolerance that all coordinates *must* be within to allow an append.</span>
<span class="sd">            It is important that this value is smaller than half the distance between</span>
<span class="sd">            the two closests atoms such that there is no ambiguity in selecting</span>
<span class="sd">            equivalent atoms. An internal stricter eps is used as a baseline, see above.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        prepend : equivalent scheme as this method</span>
<span class="sd">        transpose : ensure hermiticity by using this routine</span>
<span class="sd">        Geometry.append</span>
<span class="sd">        Geometry.prepend</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError if atomic coordinates does not overlap within `eps`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        object</span>
<span class="sd">            a new instance with two sparse matrices joined and appended together</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.append requires other to be of same type: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.append requires sparse-geometries to maximally &#39;</span>
                             <span class="s1">&#39;have 3 supercells along appending axis.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">nsc</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">nsc</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.append requires sparse-geometries to have the same &#39;</span>
                             <span class="s1">&#39;number of supercells along all directions.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.append requires the same number of dimensions in the matrix&#39;</span><span class="p">)</span>

        <span class="c1"># Create sparsity pattern in the atomic picture.</span>
        <span class="c1"># This makes it easier to find the coupling elements along axis.</span>
        <span class="c1"># It could also be done in the orbital space...</span>

        <span class="k">def</span> <span class="nf">_sep_connections</span><span class="p">(</span><span class="n">spO</span><span class="p">,</span> <span class="n">direction</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Finds atoms that has connections crossing the `axis` along `direction`</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            self_connect</span>
<span class="sd">                atoms in `spO` which connects across `direction`</span>
<span class="sd">            other_connect</span>
<span class="sd">                atoms in `spO` which self_connect connects to along `direction`</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">spO</span><span class="o">.</span><span class="n">geometry</span>
            <span class="c1"># We need to copy since we are deleting elements below</span>
            <span class="n">csr</span> <span class="o">=</span> <span class="n">spO</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">copy</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># We will retain all connections crossing along the given direction</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">spO</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Figure out the matrix columns we should retain</span>
            <span class="n">nsc</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
            <span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">direction</span>

            <span class="c1"># Get all supercell indices that we should delete from the column specifications</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">n_s</span><span class="p">),</span> <span class="n">geom</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">nsc</span><span class="p">))</span> <span class="o">*</span> <span class="n">n</span>

            <span class="c1"># Calculate columns to delete</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">_a</span><span class="o">.</span><span class="n">fulli</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

            <span class="c1"># Delete all values in columns, but keep them to retain the supercell information</span>
            <span class="n">csr</span><span class="o">.</span><span class="n">delete_columns</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">keep_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Now we are in a position to find the indices along the append direction</span>
            <span class="n">self_connect</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">o2a</span><span class="p">((</span><span class="n">csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Retrieve the connected atoms in the other structure</span>
            <span class="n">other_connect</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">array_arange</span><span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">)],</span> <span class="kc">True</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">self_connect</span><span class="p">,</span> <span class="n">other_connect</span>

        <span class="c1"># Naming convention:</span>
        <span class="c1">#  P_01 -&gt; [0] -&gt; [1]</span>
        <span class="c1">#  P_10 -&gt; [1] -&gt; [0]</span>
        <span class="c1">#  M_01 -&gt; [0] -&gt; [-1]</span>
        <span class="c1">#  M_10 -&gt; [-1] -&gt; [0]</span>
        <span class="n">self_P_01</span><span class="p">,</span> <span class="n">self_P_10</span> <span class="o">=</span> <span class="n">_sep_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">self_M_01</span><span class="p">,</span> <span class="n">self_M_10</span> <span class="o">=</span> <span class="n">_sep_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">other_P_01</span><span class="p">,</span> <span class="n">other_P_10</span> <span class="o">=</span> <span class="n">_sep_connections</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">other_M_01</span><span class="p">,</span> <span class="n">other_M_10</span> <span class="o">=</span> <span class="n">_sep_connections</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># I.e. the connections in the supercell picture will be:</span>
        <span class="c1"># Note that all indices are not in any supercell (which is why we need to</span>
        <span class="c1"># translate them anyhow).</span>

        <span class="k">def</span> <span class="nf">_find_overlap</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g1_idx</span><span class="p">,</span> <span class="n">isc1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">g2_idx</span><span class="p">,</span> <span class="n">isc2</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Finds `g1_idx` atoms in `g2_idx` &quot;&quot;&quot;</span>
            <span class="n">xyz1</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">g1_idx</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="n">isc1</span><span class="p">)</span>
            <span class="n">g1_g2</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">warn_atoms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">xyz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">g1_idx</span><span class="p">,</span> <span class="n">xyz1</span><span class="p">):</span>
                <span class="c1"># Only search in the index</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">g2</span><span class="o">.</span><span class="n">close_sc</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">isc2</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="n">g2_idx</span><span class="p">)</span>
                <span class="n">g1_g2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_check</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">warn_atoms</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">g1_g2</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">warn_atoms</span>

        <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">warn_atoms</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warn_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.append found incompatible self/other within the given eps value.&#39;</span><span class="p">)</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.append found two atoms close to a mirror atom, a too high eps value was given.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">idx</span>

        <span class="c1"># Radius to use as precision array</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">([</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">eps</span><span class="p">])</span>

        <span class="c1"># Initialize arrays for checking</span>
        <span class="n">self_isc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
        <span class="n">other_isc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>

        <span class="k">def</span> <span class="nf">_2</span><span class="p">(</span><span class="n">spg1</span><span class="p">,</span> <span class="n">spg1_idx</span><span class="p">,</span> <span class="n">spg1_isc</span><span class="p">,</span> <span class="n">spg2</span><span class="p">,</span> <span class="n">spg2_idx</span><span class="p">,</span> <span class="n">spg2_isc</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
            <span class="n">_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.append(</span><span class="si">{}</span><span class="s1">) &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">idx</span><span class="p">,</span> <span class="n">warn_atoms</span> <span class="o">=</span> <span class="n">_find_overlap</span><span class="p">(</span><span class="n">spg1</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">spg1_idx</span><span class="p">,</span> <span class="n">spg1_isc</span><span class="p">,</span>
                                            <span class="n">spg2</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">spg2_idx</span><span class="p">,</span> <span class="n">spg2_isc</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spg1_idx</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spg2_idx</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_error</span> <span class="o">+</span> <span class="s1">&#39;did not find an equivalent overlap atoms between the two geometries.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spg2_idx</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_error</span> <span class="o">+</span> <span class="s1">&#39;did not find all overlapping atoms.&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">warn_atoms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Sort them and ensure they are a list</span>
                <span class="n">warn_atoms</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">warn_atoms</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="n">warn</span><span class="p">(</span><span class="n">_error</span> <span class="o">+</span> <span class="s1">&#39;atoms farther than 0.001 Ang: </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">warn_atoms</span><span class="p">))</span>

            <span class="c1"># Now we have the atomic indices that we know are &quot;dublicated&quot;</span>
            <span class="c1"># Ensure the number of orbitals are the same in both geometries</span>
            <span class="c1"># (we don&#39;t check explicitly names etc. since this should be the users</span>
            <span class="c1">#  responsibility)</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="n">spg1</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">spg1_idx</span><span class="p">)</span><span class="o">.</span><span class="n">reorder</span><span class="p">()</span><span class="o">.</span><span class="n">firsto</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="n">spg2</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">reorder</span><span class="p">()</span><span class="o">.</span><span class="n">firsto</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_error</span> <span class="o">+</span> <span class="s1">&#39;requires geometries to have the same &#39;</span>
                                 <span class="s1">&#39;number of orbitals in the overlapping region.&#39;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">idx</span>

        <span class="c1"># in the full sparse geometry:</span>
        <span class="c1"># [0] &lt;-&gt; [0]</span>
        <span class="n">self_isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">other_isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">self_P_10_to_other_M_01</span> <span class="o">=</span> <span class="n">_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">self_P_10</span><span class="p">,</span> <span class="n">self_isc</span><span class="p">,</span>
                                     <span class="n">other</span><span class="p">,</span> <span class="n">other_M_01</span><span class="p">,</span> <span class="n">other_isc</span><span class="p">,</span> <span class="s1">&#39;self[0] -&gt; other[0]&#39;</span><span class="p">)</span>

        <span class="n">self_isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">other_isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">other_M_10_to_self_P_01</span> <span class="o">=</span> <span class="n">_2</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">other_M_10</span><span class="p">,</span> <span class="n">other_isc</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="p">,</span> <span class="n">self_P_01</span><span class="p">,</span> <span class="n">self_isc</span><span class="p">,</span> <span class="s1">&#39;other[0] -&gt; self[0]&#39;</span><span class="p">)</span>

        <span class="c1"># [0] -&gt; [-1]</span>
        <span class="n">self_isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">other_isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">self_M_10_to_other_P_01</span> <span class="o">=</span> <span class="n">_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">self_M_10</span><span class="p">,</span> <span class="n">self_isc</span><span class="p">,</span>
                                     <span class="n">other</span><span class="p">,</span> <span class="n">other_P_01</span><span class="p">,</span> <span class="n">other_isc</span><span class="p">,</span> <span class="s1">&#39;self[0] -&gt; other[-1]&#39;</span><span class="p">)</span>

        <span class="c1"># [0] -&gt; [1]</span>
        <span class="n">self_isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">other_isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">other_P_10_to_self_M_01</span> <span class="o">=</span> <span class="n">_2</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">other_P_10</span><span class="p">,</span> <span class="n">other_isc</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="p">,</span> <span class="n">self_M_01</span><span class="p">,</span> <span class="n">self_isc</span><span class="p">,</span> <span class="s1">&#39;other[0] -&gt; self[1]&#39;</span><span class="p">)</span>

        <span class="c1"># Clean-up</span>
        <span class="k">del</span> <span class="n">self_isc</span><span class="p">,</span> <span class="n">other_isc</span>

        <span class="c1"># Now we have the following operations to perform</span>
        <span class="n">self_no</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span>
        <span class="n">other_no</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span>
        <span class="n">total_no</span> <span class="o">=</span> <span class="n">self_no</span> <span class="o">+</span> <span class="n">other_no</span>

        <span class="c1"># Now create the combined geometry + sparse matrix</span>
        <span class="n">total_geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="n">total_geom</span><span class="o">.</span><span class="n">sc</span>

        <span class="c1"># 1. create a copy of the sparse-geometries</span>
        <span class="c1"># 2. translate old columns to new columns</span>
        <span class="c1"># 3. merge the two</span>
        <span class="c1"># 4. insert the overlapping stuff (both +/-)</span>
        <span class="n">self_o2n</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">self_no</span><span class="p">)</span>
        <span class="n">self_o2n</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">self_o2n</span> <span class="o">=</span> <span class="n">self_o2n</span> <span class="o">+</span> <span class="n">sc</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">total_no</span>
        <span class="n">self_o2n</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>

        <span class="n">other_o2n</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">other_no</span><span class="p">)</span> <span class="o">+</span> <span class="n">self_no</span>
        <span class="n">other_o2n</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">other_o2n</span> <span class="o">=</span> <span class="n">other_o2n</span> <span class="o">+</span> <span class="n">sc</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">total_no</span>
        <span class="n">other_o2n</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>

        <span class="c1"># Create a template new sparse matrix</span>
        <span class="n">self_csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>
        <span class="n">other_csr</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_csr</span>

        <span class="n">total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Overwrite geometry</span>
        <span class="n">total</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">total_geom</span>
        <span class="n">n_s</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">n_s</span>

        <span class="c1"># Correct the new csr shape</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="n">total</span><span class="o">.</span><span class="n">_csr</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">total_no</span><span class="p">,</span> <span class="n">total_no</span> <span class="o">*</span> <span class="n">n_s</span><span class="p">,</span> <span class="n">csr</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>

        <span class="c1"># Fix columns in the self part</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">)</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">self_o2n</span><span class="p">[</span><span class="n">csr</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>

        <span class="c1"># Now add the `other` sparse data while fixing the supercell indices</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">other_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">,</span> <span class="n">other_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># We use take since other_csr.col may contain non-finalized elements (i.e. too large values)</span>
        <span class="c1"># In this case we use take to *clip* the indices to the largest available one.</span>
        <span class="c1"># This may be done since col elements not touched by the .ptr + .ncol will never</span>
        <span class="c1"># be used.</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">csr</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">take</span><span class="p">(</span><span class="n">other_o2n</span><span class="p">,</span> <span class="n">other_csr</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="p">,</span> <span class="n">other_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Small clean-up</span>
        <span class="k">del</span> <span class="n">self_o2n</span><span class="p">,</span> <span class="n">other_o2n</span><span class="p">,</span> <span class="n">idx</span>

        <span class="c1"># At this point `csr` contains all data.</span>
        <span class="c1"># but the columns are incorrect. I.e. self -&gt; self along the append axis</span>
        <span class="c1"># where it should connect to `other`.</span>

        <span class="c1"># Below we are correcting the column indices such that they</span>
        <span class="c1"># connect to the proper things.</span>
        <span class="c1"># Since some systems has crossings over diagonal supercells we need</span>
        <span class="c1"># all supercells with a non-zero component along the axis</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>

        <span class="k">def</span> <span class="nf">_transfer_indices</span><span class="p">(</span><span class="n">csr</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">old_col</span><span class="p">,</span> <span class="n">new_col</span><span class="p">):</span>
            <span class="s2">&quot; Transfer indices in col to the equivalent column indices &quot;</span>
            <span class="k">if</span> <span class="n">old_col</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">new_col</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.append requires the overlapping basis to &#39;</span>
                                 <span class="s1">&#39;be equivalent. We found different number of hopping elements between &#39;</span>
                                 <span class="s1">&#39;the two regions.&#39;</span><span class="p">)</span>

            <span class="n">col_idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="n">rows</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">[</span><span class="n">rows</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">col_idx</span> <span class="o">=</span> <span class="n">col_idx</span><span class="p">[</span><span class="n">indices_only</span><span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">col_idx</span><span class="p">],</span> <span class="n">old_col</span><span class="p">)]</span>

            <span class="c1"># Indices are now the indices in csr.col such that</span>
            <span class="c1">#   col[col_idx] in old_col</span>
            <span class="c1"># Now we need to find the indices (in order)</span>
            <span class="c1"># such that</span>
            <span class="c1">#   col[col_idx] == old_col[old_idx]</span>
            <span class="c1"># This will let us do:</span>
            <span class="c1">#   col[col_idx] = new_col[old_idx]</span>
            <span class="c1"># since old_col and new_col have the same order</span>
            <span class="c1"># Since indices does not return a sorted index list</span>
            <span class="c1"># but only indices of elements in other list</span>
            <span class="c1"># we need to sort them correctly</span>
            <span class="c1"># Create the linear index that transfers from old -&gt; new</span>
            <span class="c1"># Since old_col/new_col does not contain the full supercell picture</span>
            <span class="c1"># we need to create a fake indexing converter</span>
            <span class="n">min_col</span> <span class="o">=</span> <span class="p">(</span><span class="n">old_col</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="n">csr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">csr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">max_col</span> <span class="o">=</span> <span class="p">(</span><span class="n">old_col</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="n">csr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">csr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">new_col_idx</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">max_col</span> <span class="o">-</span> <span class="n">min_col</span><span class="p">)</span>
            <span class="n">new_col_idx</span><span class="p">[</span><span class="n">old_col</span> <span class="o">-</span> <span class="n">min_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_col</span>
            <span class="n">csr</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">col_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_col_idx</span><span class="p">[</span><span class="n">csr</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">col_idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_col</span><span class="p">]</span>

        <span class="c1">## nomenclature in new supercell</span>
        <span class="c1"># self[0] -&gt; other[0]</span>

        <span class="c1"># Now we have the two matrices merged.</span>
        <span class="c1"># We now need to fix connections crossing the border</span>
        <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">self_P_01</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="c1"># We have to store isc_off since we require a one2one correspondance</span>
        <span class="c1"># of the new supercells. Also we require the supercell indices to be</span>
        <span class="c1"># sorted, and hence we sort the sc-indices (just in case)</span>
        <span class="n">isc_off</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">))</span>
        <span class="n">sc_off</span> <span class="o">=</span> <span class="n">isc_off</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">total_no</span>
        <span class="c1"># These columns should have a one-to-one correspondance</span>
        <span class="n">old_col</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">self_P_10</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">sc_off</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">)</span>
        <span class="c1"># Since we are appending we actually move it into the primary cell (this is where the</span>
        <span class="c1"># requirement of nsc == 3 comes from...)</span>
        <span class="c1"># Shift all supercell indices to the primary one (along the append axis)</span>
        <span class="n">sc_off</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">isc_off</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">sc_off</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sc_off</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">sc_off</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">total_no</span> <span class="o">+</span> <span class="n">self_no</span>
        <span class="n">new_col</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">self_P_10_to_other_M_01</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">sc_off</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># Find columns in `rows` and transfer</span>
        <span class="c1"># the elements with values `old_col` -&gt; `new_col`</span>
        <span class="c1"># Since this should catch *all* elements that cross the</span>
        <span class="c1"># boundary we will only have elements that are actually used</span>
        <span class="c1"># So we need simply to reduce idx to the indices that contain the elements</span>
        <span class="c1"># in `old_col`</span>
        <span class="n">_transfer_indices</span><span class="p">(</span><span class="n">csr</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">old_col</span><span class="p">,</span> <span class="n">new_col</span><span class="p">)</span>

        <span class="c1">##</span>
        <span class="c1"># other[0] -&gt; self[0]</span>
        <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">other_M_01</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="o">+</span> <span class="n">self_no</span>
        <span class="n">isc_off</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">))</span>
        <span class="n">sc_off</span> <span class="o">=</span> <span class="n">isc_off</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">total_no</span> <span class="o">+</span> <span class="n">self_no</span>
        <span class="n">old_col</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">other_M_10</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">sc_off</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">sc_off</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">isc_off</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">sc_off</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sc_off</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">sc_off</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">total_no</span>
        <span class="n">new_col</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">other_M_10_to_self_P_01</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">sc_off</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">_transfer_indices</span><span class="p">(</span><span class="n">csr</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">old_col</span><span class="p">,</span> <span class="n">new_col</span><span class="p">)</span>

        <span class="c1">##</span>
        <span class="c1"># self[0] -&gt; other[-1]</span>
        <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">self_M_01</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">isc_off</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">))</span>
        <span class="n">sc_off</span> <span class="o">=</span> <span class="n">isc_off</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">total_no</span>
        <span class="n">old_col</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">self_M_10</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">sc_off</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">)</span>
        <span class="c1">#sc_off = sc.sc_off[isc_off, :]</span>
        <span class="c1">#sc_off[:, axis] = -1</span>
        <span class="c1">#sc_off = sc.sc_index(sc_off).reshape(-1, 1) * total_no</span>
        <span class="n">new_col</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">self_M_10_to_other_P_01</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">self_no</span> <span class="o">+</span> <span class="n">sc_off</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">_transfer_indices</span><span class="p">(</span><span class="n">csr</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">old_col</span><span class="p">,</span> <span class="n">new_col</span><span class="p">)</span>

        <span class="c1">##</span>
        <span class="c1"># other[0] -&gt; self[1]</span>
        <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">other_P_01</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="o">+</span> <span class="n">self_no</span>
        <span class="n">isc_off</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">))</span>
        <span class="n">sc_off</span> <span class="o">=</span> <span class="n">isc_off</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">total_no</span>
        <span class="n">old_col</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">other_P_10</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">self_no</span> <span class="o">+</span> <span class="n">sc_off</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">)</span>
        <span class="c1">#sc_off = sc.sc_off[isc_off, :]</span>
        <span class="c1">#sc_off[:, axis] = 1</span>
        <span class="c1">#sc_off = sc.sc_index(sc_off).reshape(-1, 1) * total_no</span>
        <span class="n">new_col</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">other_P_10_to_self_M_01</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">sc_off</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">_transfer_indices</span><span class="p">(</span><span class="n">csr</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">old_col</span><span class="p">,</span> <span class="n">new_col</span><span class="p">)</span>

        <span class="c1"># Finally figure out the number of non-zero elements</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">total</span></div>

<div class="viewcode-block" id="SparseOrbital.toSparseAtom"><a class="viewcode-back" href="../../api-generated/sisl.SparseOrbital.html#sisl.SparseOrbital.toSparseAtom">[docs]</a>    <span class="k">def</span> <span class="nf">toSparseAtom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Convert the sparse object (without data) to a new sparse object with equivalent but reduced sparse pattern</span>

<span class="sd">        This converts the orbital sparse pattern to an atomic sparse pattern.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : int, optional</span>
<span class="sd">           number of dimensions allocated in the SparseAtom object, default to the same</span>
<span class="sd">        dtype: numpy.dtype, optional</span>
<span class="sd">           used data-type for the sparse object. Defaults to the same.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>

        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>

        <span class="c1"># Create a conversion vector</span>
        <span class="n">orb2atom</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">)),</span> <span class="n">geom</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span>
        <span class="n">orb2atom</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="n">orb2atom</span> <span class="o">+=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span>
        <span class="n">orb2atom</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>

        <span class="c1"># First convert all rows to the same</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>

        <span class="c1"># Now build the new sparse pattern</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyi</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">na</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">col</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span>
        <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">na</span><span class="p">):</span>

            <span class="n">o1</span><span class="p">,</span> <span class="n">o2</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">a2o</span><span class="p">([</span><span class="n">ia</span><span class="p">,</span> <span class="n">ia</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1"># Get current atomic elements</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="n">o1</span><span class="p">:</span><span class="n">o2</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">[</span><span class="n">o1</span><span class="p">:</span><span class="n">o2</span><span class="p">])</span>

            <span class="c1"># These are now the atomic columns</span>
            <span class="c1"># Immediately reduce to unique elements</span>
            <span class="n">acol</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">orb2atom</span><span class="p">[</span><span class="n">csr</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]])</span>

            <span class="c1"># Step counters</span>
            <span class="n">col</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span> <span class="o">=</span> <span class="n">acol</span>
            <span class="n">ptr</span><span class="p">[</span><span class="n">ia</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">acol</span><span class="p">)</span>

        <span class="c1"># Now we can create the sparse atomic</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">spAtom</span> <span class="o">=</span> <span class="n">SparseAtom</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">spAtom</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">[:]</span>
        <span class="n">spAtom</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
        <span class="n">spAtom</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span>
        <span class="n">spAtom</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">),</span> <span class="n">dim</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">spAtom</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="n">spAtom</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># unique returns sorted elements</span>
        <span class="k">return</span> <span class="n">spAtom</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2018, Nick R. Papior

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>