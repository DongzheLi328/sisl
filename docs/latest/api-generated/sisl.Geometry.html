

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Geometry &mdash; sisl |release| documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="SuperCell" href="sisl.SuperCell.html" />
    <link rel="prev" title="Atoms" href="sisl.Atoms.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> sisl
          

          
          </a>

          
            
            
              <div class="version">
                latest
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../other.html">Other resources</a></li>
</ul>
<p class="caption"><span class="caption-text">Publications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../cite.html">Citing sisl</a></li>
<li class="toctree-l1"><a class="reference internal" href="../publications.html">Publications using sisl</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scripts/scripts.html">Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rst/files.html">File formats</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference documentation</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../api.html">API documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="sisl.html">sisl (<code class="xref py py-mod docutils literal notranslate"><span class="pre">sisl</span></code>)</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="sisl.html#generic-classes">Generic classes</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="sisl.PeriodicTable.html">PeriodicTable</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.Orbital.html">Orbital</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.SphericalOrbital.html">SphericalOrbital</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.AtomicOrbital.html">AtomicOrbital</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.Atom.html">Atom</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.Atoms.html">Atoms</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">Geometry</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.SuperCell.html">SuperCell</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.Grid.html">Grid</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="sisl.html#advanced-classes">Advanced classes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="sisl.geom.html">Common geometries (<code class="xref py py-mod docutils literal notranslate"><span class="pre">sisl.geom</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.physics.html">Physical objects (<code class="xref py py-mod docutils literal notranslate"><span class="pre">sisl.physics</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.io.html">Input/Output (<code class="xref py py-mod docutils literal notranslate"><span class="pre">sisl.io</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.constant.html">Physical constants (<code class="xref py py-mod docutils literal notranslate"><span class="pre">sisl.constant</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.unit.html">Unit conversion (<code class="xref py py-mod docutils literal notranslate"><span class="pre">sisl.unit</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.shape.html">Shapes (<code class="xref py py-mod docutils literal notranslate"><span class="pre">sisl.shape</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.utils.html">Utility routines (<code class="xref py py-mod docutils literal notranslate"><span class="pre">sisl.utils</span></code>)</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">sisl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../api.html">API documentation</a> &raquo;</li>
        
          <li><a href="sisl.html">sisl (<code class="xref py py-mod docutils literal notranslate"><span class="pre">sisl</span></code>)</a> &raquo;</li>
        
      <li>Geometry</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api-generated/sisl.Geometry.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast,
.nboutput.nblast {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast + .nbinput {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="geometry">
<h1>Geometry<a class="headerlink" href="#geometry" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="sisl.Geometry">
<em class="property">class </em><code class="descclassname">sisl.</code><code class="descname">Geometry</code><span class="sig-paren">(</span><em>xyz</em>, <em>atom=None</em>, <em>sc=None</em>, <em>names=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Holds atomic information, coordinates, species, lattice vectors</p>
<p>The <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry</span></code></a> class holds information regarding atomic coordinates,
the atomic species, the corresponding lattice-vectors.</p>
<p>It enables the interaction and conversion of atomic structures via
simple routine methods.</p>
<p>All lengths are assumed to be in units of Angstrom, however, as
long as units are kept same the exact units are irrespective.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]],</span> <span class="n">Atom</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>                  <span class="n">sc</span><span class="o">=</span><span class="n">SuperCell</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">nsc</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">square</span><span class="p">)</span>
<span class="go">Geometry{na: 1, no: 1,</span>
<span class="go"> Atoms{species: 1,</span>
<span class="go">  Atom{H, Z: 1, mass(au): 1.00794, maxR: -1.00000,</span>
<span class="go">   Orbital{R: -1.00000, q0: 0.0}</span>
<span class="go">  }: 1,</span>
<span class="go"> },</span>
<span class="go"> maxR: -1.00000,</span>
<span class="go"> SuperCell{volume: 1.0000e+01, nsc: [3 3 1]}</span>
<span class="go">}</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xyz</strong><span class="classifier">array_like</span></dt><dd><p>atomic coordinates
<code class="docutils literal notranslate"><span class="pre">xyz[i,</span> <span class="pre">:]</span></code> is the atomic coordinate of the i’th atom.</p>
</dd>
<dt><strong>atom</strong><span class="classifier">array_like or Atoms</span></dt><dd><p>atomic species retrieved from the <a class="reference internal" href="sisl.PeriodicTable.html#sisl.PeriodicTable" title="sisl.PeriodicTable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PeriodicTable</span></code></a></p>
</dd>
<dt><strong>sc</strong><span class="classifier">SuperCell</span></dt><dd><p>the unit-cell describing the atoms in a periodic
super-cell</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="sisl.Atoms.html#sisl.Atoms" title="sisl.Atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Atoms</span></code></a></dt><dd><p>contained atoms <em class="xref py py-obj">self.atoms</em></p>
</dd>
<dt><a class="reference internal" href="sisl.Atom.html#sisl.Atom" title="sisl.Atom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Atom</span></code></a></dt><dd><p>contained atoms are each an object of this</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>An atomic cubic lattice of Hydrogen atoms</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xyz</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span> <span class="o">=</span> <span class="n">SuperCell</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">),</span> <span class="n">sc</span><span class="p">)</span>
</pre></div>
</div>
<p>The following estimates the lattice vectors from the
atomic coordinates, although possible, it is not recommended
to be used.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xyz</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">))</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.na" title="sisl.Geometry.na"><code class="xref py py-obj docutils literal notranslate"><span class="pre">na</span></code></a></dt><dd><p>Number of atoms in geometry</p>
</dd>
<dt><strong>xyz</strong><span class="classifier">ndarray</span></dt><dd><p>atomic coordinates</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a></dt><dd><p>Atoms for the geometry (<a class="reference internal" href="sisl.Atoms.html#sisl.Atoms" title="sisl.Atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Atoms</span></code></a> object)</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.orbitals" title="sisl.Geometry.orbitals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orbitals</span></code></a></dt><dd><p>List of orbitals per atom</p>
</dd>
<dt><strong>sc</strong><span class="classifier">SuperCell</span></dt><dd><p>the supercell describing the periodicity of the
geometry</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.no" title="sisl.Geometry.no"><code class="xref py py-obj docutils literal notranslate"><span class="pre">no</span></code></a></dt><dd><p>Number of orbitals</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.n_s" title="sisl.Geometry.n_s"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_s</span></code></a><span class="classifier">int</span></dt><dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.n_s" title="sisl.Geometry.n_s"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_s</span></code></a></p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.no_s" title="sisl.Geometry.no_s"><code class="xref py py-obj docutils literal notranslate"><span class="pre">no_s</span></code></a><span class="classifier">int</span></dt><dd><p>Number of supercell orbitals</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Attributes</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.atom" title="sisl.Geometry.atom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atom</span></code></a></p></td>
<td><p>Atoms for the geometry (<a class="reference internal" href="sisl.Atoms.html#sisl.Atoms" title="sisl.Atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Atoms</span></code></a> object)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a></p></td>
<td><p>Atoms for the geometry (<a class="reference internal" href="sisl.Atoms.html#sisl.Atoms" title="sisl.Atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Atoms</span></code></a> object)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.cell" title="sisl.Geometry.cell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cell</span></code></a></p></td>
<td><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.cell" title="sisl.Geometry.cell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cell</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.firsto" title="sisl.Geometry.firsto"><code class="xref py py-obj docutils literal notranslate"><span class="pre">firsto</span></code></a></p></td>
<td><p>The first orbital on the corresponding atom</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.fxyz" title="sisl.Geometry.fxyz"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fxyz</span></code></a></p></td>
<td><p>Returns geometry coordinates in fractional coordinates</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.icell" title="sisl.Geometry.icell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">icell</span></code></a></p></td>
<td><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.icell" title="sisl.Geometry.icell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">icell</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.isc_off" title="sisl.Geometry.isc_off"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isc_off</span></code></a></p></td>
<td><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.isc_off" title="sisl.Geometry.isc_off"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isc_off</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.lasto" title="sisl.Geometry.lasto"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lasto</span></code></a></p></td>
<td><p>The last orbital on the corresponding atom</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.mass" title="sisl.Geometry.mass"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass</span></code></a></p></td>
<td><p>The mass of all atoms as an array</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.n_s" title="sisl.Geometry.n_s"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_s</span></code></a></p></td>
<td><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.n_s" title="sisl.Geometry.n_s"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_s</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.na" title="sisl.Geometry.na"><code class="xref py py-obj docutils literal notranslate"><span class="pre">na</span></code></a></p></td>
<td><p>Number of atoms in geometry</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.na_s" title="sisl.Geometry.na_s"><code class="xref py py-obj docutils literal notranslate"><span class="pre">na_s</span></code></a></p></td>
<td><p>Number of supercell atoms</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.names" title="sisl.Geometry.names"><code class="xref py py-obj docutils literal notranslate"><span class="pre">names</span></code></a></p></td>
<td><p>The named index specifier</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.no" title="sisl.Geometry.no"><code class="xref py py-obj docutils literal notranslate"><span class="pre">no</span></code></a></p></td>
<td><p>Number of orbitals</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.no_s" title="sisl.Geometry.no_s"><code class="xref py py-obj docutils literal notranslate"><span class="pre">no_s</span></code></a></p></td>
<td><p>Number of supercell orbitals</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.nsc" title="sisl.Geometry.nsc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nsc</span></code></a></p></td>
<td><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.nsc" title="sisl.Geometry.nsc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nsc</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.orbitals" title="sisl.Geometry.orbitals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orbitals</span></code></a></p></td>
<td><p>List of orbitals per atom</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.origo" title="sisl.Geometry.origo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">origo</span></code></a></p></td>
<td><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.origo" title="sisl.Geometry.origo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">origo</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.q0" title="sisl.Geometry.q0"><code class="xref py py-obj docutils literal notranslate"><span class="pre">q0</span></code></a></p></td>
<td><p>Total initial charge in this geometry (sum of q0 in all atoms)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.rcell" title="sisl.Geometry.rcell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rcell</span></code></a></p></td>
<td><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.rcell" title="sisl.Geometry.rcell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rcell</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.sc_off" title="sisl.Geometry.sc_off"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sc_off</span></code></a></p></td>
<td><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.sc_off" title="sisl.Geometry.sc_off"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sc_off</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.volume" title="sisl.Geometry.volume"><code class="xref py py-obj docutils literal notranslate"><span class="pre">volume</span></code></a></p></td>
<td><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <em class="xref py py-obj">vol</em></p></td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.Rij" title="sisl.Geometry.Rij"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Rij</span></code></a>(self, ia, ja)</p></td>
<td><p>Vector between atom <em class="xref py py-obj">ia</em> and <em class="xref py py-obj">ja</em>, atoms can be in super-cell indices</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__init__</span></code>(self, xyz[, atom, sc, names])</p></td>
<td><p>Initialize self.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.a2isc" title="sisl.Geometry.a2isc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">a2isc</span></code></a>(self, ia)</p></td>
<td><p>Returns super-cell index for a specific/list atom</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.a2o" title="sisl.Geometry.a2o"><code class="xref py py-obj docutils literal notranslate"><span class="pre">a2o</span></code></a>(self, ia[, all])</p></td>
<td><p>Returns an orbital index of the first orbital of said atom.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.a2sc" title="sisl.Geometry.a2sc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">a2sc</span></code></a>(self, a)</p></td>
<td><p>Returns the super-cell offset for a specific atom</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.a2transpose" title="sisl.Geometry.a2transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">a2transpose</span></code></a>(self, atom1[, atom2])</p></td>
<td><p>Transposes connections from <em class="xref py py-obj">atom1</em> to <em class="xref py py-obj">atom2</em> such that supercell connections are transposed</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.add" title="sisl.Geometry.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add</span></code></a>(self, other)</p></td>
<td><p>Merge two geometries (or a Geometry and SuperCell) by adding the two atoms together</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.add_vacuum" title="sisl.Geometry.add_vacuum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_vacuum</span></code></a>(self, vacuum, axis)</p></td>
<td><p>Add vacuum along the <em class="xref py py-obj">axis</em> lattice vector</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.angle" title="sisl.Geometry.angle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">angle</span></code></a>(self, atom[, dir, ref, rad])</p></td>
<td><p>The angle between atom <a class="reference internal" href="#sisl.Geometry.atom" title="sisl.Geometry.atom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atom</span></code></a> and the direction <em class="xref py py-obj">dir</em>, with possibility of a reference coordinate <em class="xref py py-obj">ref</em></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.append" title="sisl.Geometry.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a>(self, other, axis[, align])</p></td>
<td><p>Appends two structures along <em class="xref py py-obj">axis</em></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.area" title="sisl.Geometry.area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">area</span></code></a>(self, ax0, ax1)</p></td>
<td><p>Calculate the area spanned by the two axis <em class="xref py py-obj">ax0</em> and <em class="xref py py-obj">ax1</em></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.as_primary" title="sisl.Geometry.as_primary"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_primary</span></code></a>(self, na_primary[, ret_super])</p></td>
<td><p>Try and reduce the geometry to the primary unit-cell comprising <em class="xref py py-obj">na_primary</em> atoms</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.asc2uc" title="sisl.Geometry.asc2uc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">asc2uc</span></code></a>(self, atom[, unique])</p></td>
<td><p>Returns atom from supercell indices to unit-cell indices, possibly removing dublicates</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.attach" title="sisl.Geometry.attach"><code class="xref py py-obj docutils literal notranslate"><span class="pre">attach</span></code></a>(self, s_idx, other, o_idx[, dist, axis])</p></td>
<td><p>Attaches another <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry</span></code></a> at the <em class="xref py py-obj">s_idx</em> index with respect to <em class="xref py py-obj">o_idx</em> using different methods.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.auc2sc" title="sisl.Geometry.auc2sc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">auc2sc</span></code></a>(self, atom[, unique])</p></td>
<td><p>Returns atom from unit-cell indices to supercell indices, possibly removing dublicates</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.axyz" title="sisl.Geometry.axyz"><code class="xref py py-obj docutils literal notranslate"><span class="pre">axyz</span></code></a>(self[, atom, isc])</p></td>
<td><p>Return the atomic coordinates in the supercell of a given atom.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.bond_correct" title="sisl.Geometry.bond_correct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bond_correct</span></code></a>(self, ia, atom[, method])</p></td>
<td><p>Corrects the bond between <em class="xref py py-obj">ia</em> and the <a class="reference internal" href="#sisl.Geometry.atom" title="sisl.Geometry.atom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atom</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.center" title="sisl.Geometry.center"><code class="xref py py-obj docutils literal notranslate"><span class="pre">center</span></code></a>(self[, atom, what])</p></td>
<td><p>Returns the center of the geometry</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.close" title="sisl.Geometry.close"><code class="xref py py-obj docutils literal notranslate"><span class="pre">close</span></code></a>(self, xyz_ia[, R, idx, idx_xyz, …])</p></td>
<td><p>Indices of atoms in the entire supercell within a given radius from a given coordinate</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.close_sc" title="sisl.Geometry.close_sc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">close_sc</span></code></a>(self, xyz_ia[, isc, R, idx, …])</p></td>
<td><p>Indices of atoms in a given supercell within a given radius from a given coordinate</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.copy" title="sisl.Geometry.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>(self)</p></td>
<td><p>A copy of the object.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.cut" title="sisl.Geometry.cut"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cut</span></code></a>(self, seps, axis[, seg, rtol, atol])</p></td>
<td><p>A subset of atoms from the geometry by cutting the geometry into <em class="xref py py-obj">seps</em> parts along the direction <em class="xref py py-obj">axis</em>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.distance" title="sisl.Geometry.distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">distance</span></code></a>(self[, atom, R, tol, method])</p></td>
<td><p>Calculate the distances for all atoms in shells of radius <em class="xref py py-obj">tol</em> within <em class="xref py py-obj">max_R</em></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.equal" title="sisl.Geometry.equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equal</span></code></a>(self, other[, R, tol])</p></td>
<td><p>Whether two geometries are the same (optional not check of the orbital radius)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.fromASE" title="sisl.Geometry.fromASE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fromASE</span></code></a>(aseg)</p></td>
<td><p>Returns geometry from an ASE object.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.iR" title="sisl.Geometry.iR"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iR</span></code></a>(self[, na, iR, R])</p></td>
<td><p>Return an integer number of maximum radii (<code class="docutils literal notranslate"><span class="pre">self.maxR()</span></code>) which holds approximately <a class="reference internal" href="#sisl.Geometry.na" title="sisl.Geometry.na"><code class="xref py py-obj docutils literal notranslate"><span class="pre">na</span></code></a> atoms</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.insert" title="sisl.Geometry.insert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">insert</span></code></a>(self, atom, geom)</p></td>
<td><p>Inserts other atoms right before index</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.is_orthogonal" title="sisl.Geometry.is_orthogonal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_orthogonal</span></code></a>(self)</p></td>
<td><p>Return true if all cell vectors are linearly independent</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.iter" title="sisl.Geometry.iter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter</span></code></a>(self)</p></td>
<td><p>An iterator over all atomic indices</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.iter_block" title="sisl.Geometry.iter_block"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_block</span></code></a>(self[, iR, R, atom, method])</p></td>
<td><p>Iterator for performance critical loops</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.iter_block_rand" title="sisl.Geometry.iter_block_rand"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_block_rand</span></code></a>(self[, iR, R, atom])</p></td>
<td><p>Perform the <em>random</em> block-iteration by randomly selecting the next center of block</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.iter_block_shape" title="sisl.Geometry.iter_block_shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_block_shape</span></code></a>(self[, shape, iR, atom])</p></td>
<td><p>Perform the <em>grid</em> block-iteration by looping a grid</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.iter_orbitals" title="sisl.Geometry.iter_orbitals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_orbitals</span></code></a>(self[, atom, local])</p></td>
<td><p>Returns an iterator over all atoms and their associated orbitals</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.iter_species" title="sisl.Geometry.iter_species"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_species</span></code></a>(self[, atom])</p></td>
<td><p>Iterator over all atoms (or a subset) and species as a tuple in this geometry</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.maxR" title="sisl.Geometry.maxR"><code class="xref py py-obj docutils literal notranslate"><span class="pre">maxR</span></code></a>(self[, all])</p></td>
<td><p>Maximum orbital range of the atoms</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.mirror" title="sisl.Geometry.mirror"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mirror</span></code></a>(self, plane[, atom])</p></td>
<td><p>Mirrors the atomic coordinates by multiplying by -1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.move" title="sisl.Geometry.move"><code class="xref py py-obj docutils literal notranslate"><span class="pre">move</span></code></a>(self, v[, atom, cell])</p></td>
<td><p>Translates the geometry by <em class="xref py py-obj">v</em></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.o2a" title="sisl.Geometry.o2a"><code class="xref py py-obj docutils literal notranslate"><span class="pre">o2a</span></code></a>(self, io[, unique])</p></td>
<td><p>Atomic index corresponding to the orbital indicies.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.o2isc" title="sisl.Geometry.o2isc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">o2isc</span></code></a>(self, io)</p></td>
<td><p>Returns the super-cell index for a specific orbital.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.o2sc" title="sisl.Geometry.o2sc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">o2sc</span></code></a>(self, o)</p></td>
<td><p>Returns the super-cell offset for a specific orbital.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.o2transpose" title="sisl.Geometry.o2transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">o2transpose</span></code></a>(self, orb1[, orb2])</p></td>
<td><p>Transposes connections from <em class="xref py py-obj">orb1</em> to <em class="xref py py-obj">orb2</em> such that supercell connections are transposed</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.oRij" title="sisl.Geometry.oRij"><code class="xref py py-obj docutils literal notranslate"><span class="pre">oRij</span></code></a>(self, io, jo)</p></td>
<td><p>Vector between orbital <a class="reference internal" href="sisl.io.html#module-sisl.io" title="sisl.io"><code class="xref py py-obj docutils literal notranslate"><span class="pre">io</span></code></a> and <em class="xref py py-obj">jo</em>, orbitals can be in super-cell indices</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.optimize_nsc" title="sisl.Geometry.optimize_nsc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optimize_nsc</span></code></a>(self[, axis, R])</p></td>
<td><p>Optimize the number of supercell connections based on <code class="docutils literal notranslate"><span class="pre">self.maxR()</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.orij" title="sisl.Geometry.orij"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orij</span></code></a>(self, io, jo)</p></td>
<td><p>Distance between orbital <a class="reference internal" href="sisl.io.html#module-sisl.io" title="sisl.io"><code class="xref py py-obj docutils literal notranslate"><span class="pre">io</span></code></a> and <em class="xref py py-obj">jo</em>, orbitals can be in super-cell indices</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.osc2uc" title="sisl.Geometry.osc2uc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">osc2uc</span></code></a>(self, orb[, unique])</p></td>
<td><p>Returns orbitals from supercell indices to unit-cell indices, possibly removing dublicates</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.ouc2sc" title="sisl.Geometry.ouc2sc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ouc2sc</span></code></a>(self, orb[, unique])</p></td>
<td><p>Returns orbitals from unit-cell indices to supercell indices, possibly removing dublicates</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.prepend" title="sisl.Geometry.prepend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prepend</span></code></a>(self, other, axis[, align])</p></td>
<td><p>Prepend two structures along <em class="xref py py-obj">axis</em></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.read" title="sisl.Geometry.read"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read</span></code></a>(sile, \*args, \*\*kwargs)</p></td>
<td><p>Reads geometry from the <code class="xref py py-obj docutils literal notranslate"><span class="pre">Sile</span></code> using <em class="xref py py-obj">Sile.read_geometry</em></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.reduce" title="sisl.Geometry.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reduce</span></code></a>(self)</p></td>
<td><p>Remove all atoms not currently used in the <code class="docutils literal notranslate"><span class="pre">self.atoms</span></code> object</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.remove" title="sisl.Geometry.remove"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove</span></code></a>(self, atom)</p></td>
<td><p>Remove atoms from the geometry.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.reorder" title="sisl.Geometry.reorder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reorder</span></code></a>(self)</p></td>
<td><p>Reorders atoms according to first occurence in the geometry</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.repeat" title="sisl.Geometry.repeat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">repeat</span></code></a>(self, reps, axis)</p></td>
<td><p>Create a repeated geometry</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.reverse" title="sisl.Geometry.reverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reverse</span></code></a>(self[, atom])</p></td>
<td><p>Returns a reversed geometry</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.rij" title="sisl.Geometry.rij"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rij</span></code></a>(self, ia, ja)</p></td>
<td><p>Distance between atom <em class="xref py py-obj">ia</em> and <em class="xref py py-obj">ja</em>, atoms can be in super-cell indices</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.rotate" title="sisl.Geometry.rotate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate</span></code></a>(self, angle, v[, origo, atom, only, rad])</p></td>
<td><p>Rotate geometry around vector and return a new geometry</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.rotate_miller" title="sisl.Geometry.rotate_miller"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate_miller</span></code></a>(self, m, v)</p></td>
<td><p>Align Miller direction along <code class="docutils literal notranslate"><span class="pre">v</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.sc2uc" title="sisl.Geometry.sc2uc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sc2uc</span></code></a>(self, atom[, unique])</p></td>
<td><p>Returns atom from supercell indices to unit-cell indices, possibly removing dublicates</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.sc_index" title="sisl.Geometry.sc_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sc_index</span></code></a>(self, \*args, \*\*kwargs)</p></td>
<td><p>Call local <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> object <a class="reference internal" href="#sisl.Geometry.sc_index" title="sisl.Geometry.sc_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sc_index</span></code></a> function</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.scale" title="sisl.Geometry.scale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale</span></code></a>(self, scale)</p></td>
<td><p>Scale coordinates and unit-cell to get a new geometry with proper scaling</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.set_nsc" title="sisl.Geometry.set_nsc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_nsc</span></code></a>(self, \*args, \*\*kwargs)</p></td>
<td><p>Set the number of super-cells in the <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> object</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.set_sc" title="sisl.Geometry.set_sc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_sc</span></code></a>(self, sc)</p></td>
<td><p>Overwrites the local supercell</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.set_supercell" title="sisl.Geometry.set_supercell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_supercell</span></code></a>(self, sc)</p></td>
<td><p>Overwrites the local supercell</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.sort" title="sisl.Geometry.sort"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort</span></code></a>(self[, axes])</p></td>
<td><p>Return an equivalent geometry by sorting the coordinates according to the axis orders</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.sparserij" title="sisl.Geometry.sparserij"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparserij</span></code></a>(self[, dtype, na_iR, method])</p></td>
<td><p>Return the sparse matrix with all distances in the matrix</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.sub" title="sisl.Geometry.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub</span></code></a>(self, atom[, cell])</p></td>
<td><p>Create a new <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry</span></code></a> with a subset of this <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.swap" title="sisl.Geometry.swap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap</span></code></a>(self, a, b)</p></td>
<td><p>Swap a set of atoms in the geometry and return a new one</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.swapaxes" title="sisl.Geometry.swapaxes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">swapaxes</span></code></a>(self, a, b[, swap])</p></td>
<td><p>Swap the axis for the atomic coordinates and the cell vectors</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.tile" title="sisl.Geometry.tile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tile</span></code></a>(self, reps, axis)</p></td>
<td><p>Tile the geometry to create a bigger one</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.toASE" title="sisl.Geometry.toASE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">toASE</span></code></a>(self)</p></td>
<td><p>Returns the geometry as an ASE <code class="docutils literal notranslate"><span class="pre">Atoms</span></code> object</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.translate" title="sisl.Geometry.translate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">translate</span></code></a>(self, v[, atom, cell])</p></td>
<td><p>Translates the geometry by <em class="xref py py-obj">v</em></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.uc2sc" title="sisl.Geometry.uc2sc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">uc2sc</span></code></a>(self, atom[, unique])</p></td>
<td><p>Returns atom from unit-cell indices to supercell indices, possibly removing dublicates</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.within" title="sisl.Geometry.within"><code class="xref py py-obj docutils literal notranslate"><span class="pre">within</span></code></a>(self, shapes[, idx, idx_xyz, …])</p></td>
<td><p>Indices of atoms in the entire supercell within a given shape from a given coordinate</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.within_inf" title="sisl.Geometry.within_inf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">within_inf</span></code></a>(self, sc[, periodic, tol, origo])</p></td>
<td><p>Find all atoms within a provided supercell</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.within_sc" title="sisl.Geometry.within_sc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">within_sc</span></code></a>(self, shapes[, isc, idx, idx_xyz, …])</p></td>
<td><p>Indices of atoms in a given supercell within a given shape from a given coordinate</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.write" title="sisl.Geometry.write"><code class="xref py py-obj docutils literal notranslate"><span class="pre">write</span></code></a>(self, sile, \*args, \*\*kwargs)</p></td>
<td><p>Writes geometry to the <code class="xref py py-obj docutils literal notranslate"><span class="pre">Sile</span></code> using <em class="xref py py-obj">sile.write_geometry</em></p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="sisl.Geometry.Rij">
<code class="descname">Rij</code><span class="sig-paren">(</span><em>self</em>, <em>ia</em>, <em>ja</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.Rij"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.Rij" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector between atom <em class="xref py py-obj">ia</em> and <em class="xref py py-obj">ja</em>, atoms can be in super-cell indices</p>
<p>Returns the vector between two atoms:</p>
<div class="math notranslate nohighlight">
\[R_{ij} = r_j - r_i\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ia</strong><span class="classifier">int or array_like</span></dt><dd><p>atomic index of first atom</p>
</dd>
<dt><strong>ja</strong><span class="classifier">int or array_like</span></dt><dd><p>atomic indices</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.a2isc">
<code class="descname">a2isc</code><span class="sig-paren">(</span><em>self</em>, <em>ia</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.a2isc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.a2isc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns super-cell index for a specific/list atom</p>
<p>Returns a vector of 3 numbers with integers.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.a2o">
<code class="descname">a2o</code><span class="sig-paren">(</span><em>self</em>, <em>ia</em>, <em>all=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.a2o"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.a2o" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an orbital index of the first orbital of said atom.
This is particularly handy if you want to create
TB models with more than one orbital per atom.</p>
<p>Note that this will preserve the super-cell offsets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ia</strong><span class="classifier">array_like</span></dt><dd><p>Atomic indices</p>
</dd>
<dt><strong>all</strong><span class="classifier">bool, optional</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">False</span></code>, return only the first orbital corresponding to the atom,
<code class="docutils literal notranslate"><span class="pre">True</span></code>, returns list of the full atom</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.a2sc">
<code class="descname">a2sc</code><span class="sig-paren">(</span><em>self</em>, <em>a</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.a2sc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.a2sc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the super-cell offset for a specific atom</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.a2transpose">
<code class="descname">a2transpose</code><span class="sig-paren">(</span><em>self</em>, <em>atom1</em>, <em>atom2=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.a2transpose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.a2transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Transposes connections from <em class="xref py py-obj">atom1</em> to <em class="xref py py-obj">atom2</em> such that supercell connections are transposed</p>
<p>When handling supercell indices it is useful to get the <em>transposed</em> connection. I.e. if you have
a connection from site <code class="docutils literal notranslate"><span class="pre">i</span></code> (in unit cell indices) to site <code class="docutils literal notranslate"><span class="pre">j</span></code> (in supercell indices) it may be
useful to get the equivalent supercell connection such for site <code class="docutils literal notranslate"><span class="pre">j</span></code> (in unit cell indices) to
site <code class="docutils literal notranslate"><span class="pre">i</span></code> (in supercell indices) such that they correspond to the transposed coupling.</p>
<p>Note that since this transposes couplings the indices returned are always expanded to the full
length if either of the inputs are a single index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>atom1</strong><span class="classifier">array_like</span></dt><dd><p>atomic indices must have same length as <em class="xref py py-obj">atom2</em> or length 1</p>
</dd>
<dt><strong>atom2</strong><span class="classifier">array_like, optional</span></dt><dd><p>atomic indices must have same length as <em class="xref py py-obj">atom1</em> or length 1.
If not present then only <em class="xref py py-obj">atom1</em> will be returned in transposed indices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>atom2</strong><span class="classifier">array_like</span></dt><dd><p>transposed indices for atom2 (only returned if <em class="xref py py-obj">atom2</em> is not None)</p>
</dd>
<dt><strong>atom1</strong><span class="classifier">array_like</span></dt><dd><p>transposed indices for atom1</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gr</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">graphene</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">gr</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span>
<span class="go">array([0, 1, 5, 9], dtype=int32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gr</span><span class="o">.</span><span class="n">a2transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
<span class="go">(array([0, 1, 1, 1], dtype=int32), array([ 0,  0, 14, 10], dtype=int32))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge two geometries (or a Geometry and SuperCell) by adding the two atoms together</p>
<p>If <em class="xref py py-obj">other</em> is a Geometry only the atoms gets added, to also add the supercell vectors
simply do <code class="docutils literal notranslate"><span class="pre">geom.add(other).add(other.sc)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Geometry or SuperCell</span></dt><dd><p>Other geometry class which is added</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.append" title="sisl.Geometry.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a></dt><dd><p>appending geometries</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.prepend" title="sisl.Geometry.prepend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prepend</span></code></a></dt><dd><p>prending geometries</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.attach" title="sisl.Geometry.attach"><code class="xref py py-obj docutils literal notranslate"><span class="pre">attach</span></code></a></dt><dd><p>attach a geometry</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.insert" title="sisl.Geometry.insert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">insert</span></code></a></dt><dd><p>insert a geometry</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.add_vacuum">
<code class="descname">add_vacuum</code><span class="sig-paren">(</span><em>self</em>, <em>vacuum</em>, <em>axis</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.add_vacuum" title="Permalink to this definition">¶</a></dt>
<dd><p>Add vacuum along the <em class="xref py py-obj">axis</em> lattice vector</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vacuum</strong><span class="classifier">float</span></dt><dd><p>amount of vacuum added, in Ang</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>the lattice vector to add vacuum along</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.angle">
<code class="descname">angle</code><span class="sig-paren">(</span><em>self</em>, <em>atom</em>, <em>dir=(1.0</em>, <em>0</em>, <em>0)</em>, <em>ref=None</em>, <em>rad=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.angle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.angle" title="Permalink to this definition">¶</a></dt>
<dd><p>The angle between atom <a class="reference internal" href="#sisl.Geometry.atom" title="sisl.Geometry.atom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atom</span></code></a> and the direction <em class="xref py py-obj">dir</em>, with possibility of a reference coordinate <em class="xref py py-obj">ref</em></p>
<p>The calculated angle can be written as this</p>
<div class="math notranslate nohighlight">
\[\alpha = \arccos \frac{(\mathrm{atom} - \mathrm{ref})\cdot \mathrm{dir}}
{|\mathrm{atom}-\mathrm{ref}||\mathrm{dir}|}\]</div>
<p>and thus lies in the interval <span class="math notranslate nohighlight">\([0 ; \pi]\)</span> as one cannot distinguish orientation without
additional vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>atom</strong><span class="classifier">int or array_like</span></dt><dd><p>indices/boolean of all atoms to be removed</p>
</dd>
<dt><strong>dir</strong><span class="classifier">str, int or vector</span></dt><dd><p>the direction from which the angle is calculated from, default to <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
</dd>
<dt><strong>ref</strong><span class="classifier">int or coordinate, optional</span></dt><dd><p>the reference point from which the vectors are drawn, default to origo</p>
</dd>
<dt><strong>rad</strong><span class="classifier">bool, optional</span></dt><dd><p>whether the returned value is in radians</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>self</em>, <em>other</em>, <em>axis</em>, <em>align='none'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends two structures along <em class="xref py py-obj">axis</em></p>
<p>This will automatically add the <code class="docutils literal notranslate"><span class="pre">self.cell[axis,:]</span></code> to all atomic
coordiates in the <em class="xref py py-obj">other</em> structure before appending.</p>
<p>The basic algorithm is this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">oxa</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:][</span><span class="kc">None</span><span class="p">,:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span><span class="n">oxa</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:]</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:]</span>
</pre></div>
</div>
<p>NOTE: The cell appended is only in the axis that
is appended, which means that the other cell directions
need not conform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Geometry or SuperCell</span></dt><dd><p>Other geometry class which needs to be appended
If a <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> only the super cell will be extended</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>Cell direction to which the <em class="xref py py-obj">other</em> geometry should be
appended.</p>
</dd>
<dt><strong>align</strong><span class="classifier">{‘none’, ‘min’}</span></dt><dd><p>By default appending two structures will simply use the coordinates,
as is.
With ‘min’, the routine will shift both the structures along the cell
axis of <em class="xref py py-obj">self</em> such that they coincide at the first atom.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.add" title="sisl.Geometry.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add</span></code></a></dt><dd><p>add geometries</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.prepend" title="sisl.Geometry.prepend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prepend</span></code></a></dt><dd><p>prending geometries</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.attach" title="sisl.Geometry.attach"><code class="xref py py-obj docutils literal notranslate"><span class="pre">attach</span></code></a></dt><dd><p>attach a geometry</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.insert" title="sisl.Geometry.insert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">insert</span></code></a></dt><dd><p>insert a geometry</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.area">
<code class="descname">area</code><span class="sig-paren">(</span><em>self</em>, <em>ax0</em>, <em>ax1</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.area" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the area spanned by the two axis <em class="xref py py-obj">ax0</em> and <em class="xref py py-obj">ax1</em></p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.as_primary">
<code class="descname">as_primary</code><span class="sig-paren">(</span><em>self</em>, <em>na_primary</em>, <em>ret_super=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.as_primary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.as_primary" title="Permalink to this definition">¶</a></dt>
<dd><p>Try and reduce the geometry to the primary unit-cell comprising <em class="xref py py-obj">na_primary</em> atoms</p>
<p>This will basically try and find the tiling/repetitions required for the geometry to only have
<em class="xref py py-obj">na_primary</em> atoms in the unit cell.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>na_primary</strong><span class="classifier">int</span></dt><dd><p>number of atoms in the primary unit cell</p>
</dd>
<dt><strong>ret_super</strong><span class="classifier">bool, optional</span></dt><dd><p>also return the number of supercells used in each direction</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Geometry</dt><dd><p>the primary unit cell</p>
</dd>
<dt>SuperCell</dt><dd><p>the tiled supercell numbers used to find the primary unit cell (only if <em class="xref py py-obj">ret_super</em> is true)</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>SislError</strong><span class="classifier">in case the algorithm fails.</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.asc2uc">
<code class="descname">asc2uc</code><span class="sig-paren">(</span><em>self</em>, <em>atom</em>, <em>unique=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.asc2uc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns atom from supercell indices to unit-cell indices, possibly removing dublicates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>atom</strong><span class="classifier">array_like or int</span></dt><dd><p>the atomic supercell indices to be converted to unit-cell indices</p>
</dd>
<dt><strong>unique</strong><span class="classifier">bool, optional</span></dt><dd><p>If True the returned indices are unique and sorted.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.atom">
<code class="descname">atom</code><a class="headerlink" href="#sisl.Geometry.atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Atoms for the geometry (<a class="reference internal" href="sisl.Atoms.html#sisl.Atoms" title="sisl.Atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Atoms</span></code></a> object)</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.atoms">
<code class="descname">atoms</code><a class="headerlink" href="#sisl.Geometry.atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Atoms for the geometry (<a class="reference internal" href="sisl.Atoms.html#sisl.Atoms" title="sisl.Atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Atoms</span></code></a> object)</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.attach">
<code class="descname">attach</code><span class="sig-paren">(</span><em>self</em>, <em>s_idx</em>, <em>other</em>, <em>o_idx</em>, <em>dist='calc'</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.attach"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.attach" title="Permalink to this definition">¶</a></dt>
<dd><p>Attaches another <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry</span></code></a> at the <em class="xref py py-obj">s_idx</em> index with respect to <em class="xref py py-obj">o_idx</em> using different methods.</p>
<p>The attached geometry will be inserted at the end of the geometry via <a class="reference internal" href="#sisl.Geometry.add" title="sisl.Geometry.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>s_idx</strong><span class="classifier">int</span></dt><dd><p>atomic index which is the base position of the attachment. The distance
between <em class="xref py py-obj">s_idx</em> and <em class="xref py py-obj">o_idx</em> is <em class="xref py py-obj">dist</em>.</p>
</dd>
<dt><strong>other</strong><span class="classifier">Geometry</span></dt><dd><p>the other Geometry to attach at the given point. In this case <em class="xref py py-obj">dist</em> from
<em class="xref py py-obj">s_idx</em>.</p>
</dd>
<dt><strong>o_idx</strong><span class="classifier">int</span></dt><dd><p>the index of the atom in <em class="xref py py-obj">other</em> that is inserted at <em class="xref py py-obj">s_idx</em>.</p>
</dd>
<dt><strong>dist</strong><span class="classifier">array_like or float or str, optional</span></dt><dd><p>the distance (in <em class="xref py py-obj">Ang</em>) between the attached coordinates.
If <em class="xref py py-obj">dist</em> is <em class="xref py py-obj">arraylike it should be the vector between
the atoms;
if `dist</em> is <em class="xref py py-obj">float</em> the argument <em class="xref py py-obj">axis</em> is required
and the vector will be calculated along the corresponding latticevector;
else if <em class="xref py py-obj">dist</em> is <em class="xref py py-obj">str</em> this will correspond to the
<em class="xref py py-obj">method</em> argument of the <code class="docutils literal notranslate"><span class="pre">Atom.radius</span></code> class of the two
atoms. Here <em class="xref py py-obj">axis</em> is also required.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>specify the direction of the lattice vectors used.
Not used if <em class="xref py py-obj">dist</em> is an array-like argument.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.auc2sc">
<code class="descname">auc2sc</code><span class="sig-paren">(</span><em>self</em>, <em>atom</em>, <em>unique=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.auc2sc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns atom from unit-cell indices to supercell indices, possibly removing dublicates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>atom</strong><span class="classifier">array_like or int</span></dt><dd><p>the atomic unit-cell indices to be converted to supercell indices</p>
</dd>
<dt><strong>unique</strong><span class="classifier">bool, optional</span></dt><dd><p>If True the returned indices are unique and sorted.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.axyz">
<code class="descname">axyz</code><span class="sig-paren">(</span><em>self</em>, <em>atom=None</em>, <em>isc=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.axyz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.axyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the atomic coordinates in the supercell of a given atom.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Geometry[...]</span></code> slicing is calling this function with appropriate options.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>atom</strong><span class="classifier">int or array_like</span></dt><dd><p>atom(s) from which we should return the coordinates, the atomic indices
may be in supercell format.</p>
</dd>
<dt><strong>isc</strong><span class="classifier">array_like, optional</span></dt><dd><p>Returns the atomic coordinates shifted according to the integer
parts of the cell. Defaults to the unit-cell</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">sc</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">isc</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span> <span class="c1"># doctest: +NORMALIZE_WHITESPACE</span>
<span class="go">[[1.   0.   0. ]</span>
<span class="go"> [1.5  0.   0. ]]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">sc</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="c1"># doctest: +NORMALIZE_WHITESPACE</span>
<span class="go">[0.  0.  0.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.bond_correct">
<code class="descname">bond_correct</code><span class="sig-paren">(</span><em>self</em>, <em>ia</em>, <em>atom</em>, <em>method='calc'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.bond_correct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.bond_correct" title="Permalink to this definition">¶</a></dt>
<dd><p>Corrects the bond between <em class="xref py py-obj">ia</em> and the <a class="reference internal" href="#sisl.Geometry.atom" title="sisl.Geometry.atom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atom</span></code></a>.</p>
<p>Corrects the bond-length between atom <em class="xref py py-obj">ia</em> and <a class="reference internal" href="#sisl.Geometry.atom" title="sisl.Geometry.atom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atom</span></code></a> in such
a way that the atomic radius is preserved.
I.e. the sum of the bond-lengths minimizes the distance matrix.</p>
<p>Only atom <em class="xref py py-obj">ia</em> is moved.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ia</strong><span class="classifier">int</span></dt><dd><p>The atom to be displaced according to the atomic radius</p>
</dd>
<dt><strong>atom</strong><span class="classifier">array_like or int</span></dt><dd><p>The atom(s) from which the radius should be reduced.</p>
</dd>
<dt><strong>method</strong><span class="classifier">str, float, optional</span></dt><dd><p>If str will use that as lookup in <a class="reference internal" href="sisl.Atom.html#sisl.Atom.radius" title="sisl.Atom.radius"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Atom.radius</span></code></a>.
Else it will be the new bond-length.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.cell">
<code class="descname">cell</code><a class="headerlink" href="#sisl.Geometry.cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.cell" title="sisl.Geometry.cell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cell</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.center">
<code class="descname">center</code><span class="sig-paren">(</span><em>self</em>, <em>atom=None</em>, <em>what='xyz'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.center"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.center" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the center of the geometry</p>
<p>By specifying <em class="xref py py-obj">what</em> one can control whether it should be:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xyz|position</span></code>: Center of coordinates (default)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mm(xyz)</span></code>: Center of minimum/maximum of coordinates</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mass</span></code>: Center of mass</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cell</span></code>: Center of cell</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>atom</strong><span class="classifier">array_like</span></dt><dd><p>list of atomic indices to find center of</p>
</dd>
<dt><strong>what</strong><span class="classifier">{‘xyz’, ‘mm(xyz)’, ‘mass’, ‘cell’}</span></dt><dd><p>determine whether center should be of ‘cell’, mass-centered (‘mass’),
center of minimum/maximum position of atoms or absolute center of the positions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.close">
<code class="descname">close</code><span class="sig-paren">(</span><em>self</em>, <em>xyz_ia</em>, <em>R=None</em>, <em>idx=None</em>, <em>idx_xyz=None</em>, <em>ret_xyz=False</em>, <em>ret_rij=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Indices of atoms in the entire supercell within a given radius from a given coordinate</p>
<p>This heavily relies on the <a class="reference internal" href="#sisl.Geometry.close_sc" title="sisl.Geometry.close_sc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">close_sc</span></code></a> method.</p>
<p>Note that if a connection is made in a neighbouring super-cell
then the atomic index is shifted by the super-cell index times
number of atoms.
This allows one to decipher super-cell atoms from unit-cell atoms.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>xyz_ia</strong><span class="classifier">coordinate/index</span></dt><dd><p>Either a point in space or an index of an atom.
If an index is passed it is the equivalent of passing
the atomic coordinate <code class="docutils literal notranslate"><span class="pre">close_sc(self.xyz[xyz_ia,:])</span></code>.</p>
</dd>
<dt><strong>R</strong><span class="classifier">(None), float/tuple of float</span></dt><dd><p>The radii parameter to where the atomic connections are found.
If <em class="xref py py-obj">R</em> is an array it will return the indices:
in the ranges:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>If a single float it will return:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span>
</pre></div>
</div>
</dd>
<dt><strong>idx</strong><span class="classifier">array_like, optional</span></dt><dd><p>List of indices for atoms that are to be considered</p>
</dd>
<dt><strong>idx_xyz</strong><span class="classifier">array_like, optional</span></dt><dd><p>The atomic coordinates of the equivalent <em class="xref py py-obj">idx</em> variable (<em class="xref py py-obj">idx</em> must also be passed)</p>
</dd>
<dt><strong>ret_xyz</strong><span class="classifier">bool, optional</span></dt><dd><p>If true this method will return the coordinates
for each of the couplings.</p>
</dd>
<dt><strong>ret_rij</strong><span class="classifier">bool, optional</span></dt><dd><p>If true this method will return the distances from the <em class="xref py py-obj">xyz_ia</em>
for each of the couplings.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>index</dt><dd><p>indices of atoms (in supercell indices) within the shells of radius <em class="xref py py-obj">R</em></p>
</dd>
<dt>xyz</dt><dd><p>atomic coordinates of the indexed atoms (only for true <em class="xref py py-obj">ret_xyz</em>)</p>
</dd>
<dt>rij</dt><dd><p>distance of the indexed atoms to the center coordinate (only for true <em class="xref py py-obj">ret_rij</em>)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.close_sc">
<code class="descname">close_sc</code><span class="sig-paren">(</span><em>self</em>, <em>xyz_ia</em>, <em>isc=(0</em>, <em>0</em>, <em>0)</em>, <em>R=None</em>, <em>idx=None</em>, <em>idx_xyz=None</em>, <em>ret_xyz=False</em>, <em>ret_rij=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.close_sc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.close_sc" title="Permalink to this definition">¶</a></dt>
<dd><p>Indices of atoms in a given supercell within a given radius from a given coordinate</p>
<p>This returns a set of atomic indices which are within a
sphere of radius <em class="xref py py-obj">R</em>.</p>
<p>If <em class="xref py py-obj">R</em> is a tuple/list/array it will return the indices:
in the ranges:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xyz_ia</strong><span class="classifier">array_like of floats or int</span></dt><dd><p>Either a point in space or an index of an atom.
If an index is passed it is the equivalent of passing
the atomic coordinate <code class="docutils literal notranslate"><span class="pre">close_sc(self.xyz[xyz_ia,:])</span></code>.</p>
</dd>
<dt><strong>isc</strong><span class="classifier">array_like, optional</span></dt><dd><p>The super-cell which the coordinates are checked in.</p>
</dd>
<dt><strong>R</strong><span class="classifier">float or array_like, optional</span></dt><dd><p>The radii parameter to where the atomic connections are found.
If <em class="xref py py-obj">R</em> is an array it will return the indices:
in the ranges <code class="docutils literal notranslate"><span class="pre">(</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">R[0]</span> <span class="pre">,</span> <span class="pre">R[0]</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">R[1],</span> <span class="pre">R[1]</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">R[2]</span> <span class="pre">)</span></code>.
If a single float it will return <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">R</span></code>.</p>
</dd>
<dt><strong>idx</strong><span class="classifier">array_like of int, optional</span></dt><dd><p>List of atoms that will be considered. This can
be used to only take out a certain atoms.</p>
</dd>
<dt><strong>idx_xyz</strong><span class="classifier">array_like of float, optional</span></dt><dd><p>The atomic coordinates of the equivalent <em class="xref py py-obj">idx</em> variable (<em class="xref py py-obj">idx</em> must also be passed)</p>
</dd>
<dt><strong>ret_xyz</strong><span class="classifier">bool, optional</span></dt><dd><p>If True this method will return the coordinates
for each of the couplings.</p>
</dd>
<dt><strong>ret_rij</strong><span class="classifier">bool, optional</span></dt><dd><p>If True this method will return the distance
for each of the couplings.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>index</dt><dd><p>indices of atoms (in supercell indices) within the shells of radius <em class="xref py py-obj">R</em></p>
</dd>
<dt>xyz</dt><dd><p>atomic coordinates of the indexed atoms (only for true <em class="xref py py-obj">ret_xyz</em>)</p>
</dd>
<dt>rij</dt><dd><p>distance of the indexed atoms to the center coordinate (only for true <em class="xref py py-obj">ret_rij</em>)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>A copy of the object.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.cut">
<code class="descname">cut</code><span class="sig-paren">(</span><em>self</em>, <em>seps</em>, <em>axis</em>, <em>seg=0</em>, <em>rtol=0.0001</em>, <em>atol=0.0001</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.cut"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.cut" title="Permalink to this definition">¶</a></dt>
<dd><p>A subset of atoms from the geometry by cutting the geometry into <em class="xref py py-obj">seps</em> parts along the direction <em class="xref py py-obj">axis</em>.</p>
<p>This will effectively change the unit-cell in the <em class="xref py py-obj">axis</em> as-well
as removing <code class="docutils literal notranslate"><span class="pre">self.na/seps</span></code> atoms.
It requires that <code class="docutils literal notranslate"><span class="pre">self.na</span> <span class="pre">%</span> <span class="pre">seps</span> <span class="pre">==</span> <span class="pre">0</span></code>.</p>
<p>REMARK: You need to ensure that all atoms within the first
cut out region are within the primary unit-cell.</p>
<p>Doing <code class="docutils literal notranslate"><span class="pre">geom.cut(2,</span> <span class="pre">1).tile(2,</span> <span class="pre">1)</span></code>, could for symmetric setups,
be equivalent to a no-op operation. A <code class="docutils literal notranslate"><span class="pre">UserWarning</span></code> will be issued
if this is not the case.</p>
<p>This method may be regarded as the opposite of <a class="reference internal" href="#sisl.Geometry.tile" title="sisl.Geometry.tile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tile</span></code></a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>seps</strong><span class="classifier">int</span></dt><dd><p>number of times the structure will be cut.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>the axis that will be cut</p>
</dd>
<dt><strong>seg</strong><span class="classifier">int, optional</span></dt><dd><p>returns the i’th segment of the cut structure
Currently the atomic coordinates are not translated,
this may change in the future.</p>
</dd>
<dt><strong>rtol</strong><span class="classifier">(tolerance for checking tiling, see <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.allclose.html#numpy.allclose" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.allclose</span></code></a>)</span></dt><dd></dd>
<dt><strong>atol</strong><span class="classifier">(tolerance for checking tiling, see <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.allclose.html#numpy.allclose" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.allclose</span></code></a>)</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.tile" title="sisl.Geometry.tile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tile</span></code></a></dt><dd><p>opposite method of this</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">sisl</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">graphene</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gxyz</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">gxyz</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.distance">
<code class="descname">distance</code><span class="sig-paren">(</span><em>self</em>, <em>atom=None</em>, <em>R=None</em>, <em>tol=0.1</em>, <em>method='average'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.distance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the distances for all atoms in shells of radius <em class="xref py py-obj">tol</em> within <em class="xref py py-obj">max_R</em></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>atom</strong><span class="classifier">int or array_like, optional</span></dt><dd><p>only create list of distances from the given atoms, default to all atoms</p>
</dd>
<dt><strong>R</strong><span class="classifier">float, optional</span></dt><dd><p>the maximum radius to consider, default to <code class="docutils literal notranslate"><span class="pre">self.maxR()</span></code>.
To retrieve all distances for atoms within the supercell structure
you can pass <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/constants.html#numpy.inf" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.inf</span></code></a>.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float or array_like, optional</span></dt><dd><p>the tolerance for grouping a set of atoms.
This parameter sets the shell radius for each shell.
I.e. the returned distances between two shells will be maximally
<code class="docutils literal notranslate"><span class="pre">2*tol</span></code>, but only if atoms are within two consecutive lists.
If this is a list, the shells will be of unequal size.</p>
<p>The first shell size will be <code class="docutils literal notranslate"><span class="pre">tol</span> <span class="pre">*</span> <span class="pre">.5</span></code> or <code class="docutils literal notranslate"><span class="pre">tol[0]</span> <span class="pre">*</span> <span class="pre">.5</span></code> if <em class="xref py py-obj">tol</em> is a list.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{‘average’, ‘mode’, ‘&lt;numpy.func&gt;’, func}</span></dt><dd><p>How the distance in each shell is determined.
A list of distances within each shell is gathered and the equivalent
method will be used to extract a single quantity from the list of
distances in the shell.
If <em class="xref py py-obj">‘mode’</em> is chosen it will use <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mode.html#scipy.stats.mode" title="(in SciPy v1.3.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.mode</span></code></a>.
If a string is given it will correspond to <code class="docutils literal notranslate"><span class="pre">getattr(numpy,</span> <span class="pre">method)</span></code>,
while any callable function may be passed. The passed function
will only be passed a list of unsorted distances that needs to be
processed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>an array of positive numbers yielding the distances from the atoms in reduced form</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.sparserij" title="sisl.Geometry.sparserij"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparserij</span></code></a></dt><dd><p>return a sparse matrix will all distances between atoms</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span> <span class="n">Atom</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="mf">1.</span><span class="p">),</span> <span class="n">sc</span><span class="o">=</span><span class="n">SuperCell</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">nsc</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">distance</span><span class="p">()</span> <span class="c1"># use geom.maxR() # doctest: +NORMALIZE_WHITESPACE</span>
<span class="go">array([1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">])</span>
<span class="go">array([1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">R</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">])</span> <span class="c1"># doctest: +NORMALIZE_WHITESPACE</span>
<span class="go">array([1.        ,  1.41421356,  2.        ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">R</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">])</span> <span class="c1"># the R = 1 and R = 2 ** .5 gets averaged # doctest: +NORMALIZE_WHITESPACE</span>
<span class="go">array([1.20710678,  2.        ])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.equal">
<code class="descname">equal</code><span class="sig-paren">(</span><em>self</em>, <em>other</em>, <em>R=True</em>, <em>tol=0.0001</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether two geometries are the same (optional not check of the orbital radius)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Geometry</span></dt><dd><p>the other Geometry to check against</p>
</dd>
<dt><strong>R</strong><span class="classifier">bool, optional</span></dt><dd><p>if True also check if the orbital radii are the same (see <a class="reference internal" href="sisl.Atom.html#sisl.Atom.equal" title="sisl.Atom.equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Atom.equal</span></code></a>)</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float, optional</span></dt><dd><p>tolerance for checking the atomic coordinates</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.firsto">
<code class="descname">firsto</code><a class="headerlink" href="#sisl.Geometry.firsto" title="Permalink to this definition">¶</a></dt>
<dd><p>The first orbital on the corresponding atom</p>
</dd></dl>

<dl class="classmethod">
<dt id="sisl.Geometry.fromASE">
<em class="property">classmethod </em><code class="descname">fromASE</code><span class="sig-paren">(</span><em>aseg</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.fromASE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.fromASE" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns geometry from an ASE object.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>aseg</strong><span class="classifier">ASE <code class="docutils literal notranslate"><span class="pre">Atoms</span></code> object which contains the following routines:</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">get_atomic_numbers</span></code>, <code class="docutils literal notranslate"><span class="pre">get_positions</span></code>, <code class="docutils literal notranslate"><span class="pre">get_cell</span></code>.
From those methods a <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry</span></code></a> object will be created.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.fxyz">
<code class="descname">fxyz</code><a class="headerlink" href="#sisl.Geometry.fxyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns geometry coordinates in fractional coordinates</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.iR">
<code class="descname">iR</code><span class="sig-paren">(</span><em>self</em>, <em>na=1000</em>, <em>iR=20</em>, <em>R=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.iR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.iR" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an integer number of maximum radii (<code class="docutils literal notranslate"><span class="pre">self.maxR()</span></code>) which holds approximately <a class="reference internal" href="#sisl.Geometry.na" title="sisl.Geometry.na"><code class="xref py py-obj docutils literal notranslate"><span class="pre">na</span></code></a> atoms</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>na</strong><span class="classifier">int, optional</span></dt><dd><p>number of atoms within the radius</p>
</dd>
<dt><strong>iR</strong><span class="classifier">int, optional</span></dt><dd><p>initial <a class="reference internal" href="#sisl.Geometry.iR" title="sisl.Geometry.iR"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iR</span></code></a> value, which the sphere is estitametd from</p>
</dd>
<dt><strong>R</strong><span class="classifier">float, optional</span></dt><dd><p>the value used for atomic range (defaults to <code class="docutils literal notranslate"><span class="pre">self.maxR()</span></code>)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>int</dt><dd><p>number of radius needed to contain <a class="reference internal" href="#sisl.Geometry.na" title="sisl.Geometry.na"><code class="xref py py-obj docutils literal notranslate"><span class="pre">na</span></code></a> atoms. Minimally 2 will be returned.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.icell">
<code class="descname">icell</code><a class="headerlink" href="#sisl.Geometry.icell" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.icell" title="sisl.Geometry.icell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">icell</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>self</em>, <em>atom</em>, <em>geom</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.insert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts other atoms right before index</p>
<p>We insert the <a class="reference internal" href="sisl.geom.html#module-sisl.geom" title="sisl.geom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">geom</span></code></a> <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry</span></code></a> before <a class="reference internal" href="#sisl.Geometry.atom" title="sisl.Geometry.atom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atom</span></code></a>.
Note that this will not change the unit cell.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>atom</strong><span class="classifier">int</span></dt><dd><p>the index at which atom the other geometry is inserted</p>
</dd>
<dt><strong>geom</strong><span class="classifier">Geometry</span></dt><dd><p>the other geometry to be inserted</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.add" title="sisl.Geometry.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add</span></code></a></dt><dd><p>add geometries</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.append" title="sisl.Geometry.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a></dt><dd><p>appending geometries</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.prepend" title="sisl.Geometry.prepend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prepend</span></code></a></dt><dd><p>prending geometries</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.attach" title="sisl.Geometry.attach"><code class="xref py py-obj docutils literal notranslate"><span class="pre">attach</span></code></a></dt><dd><p>attach a geometry</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.is_orthogonal">
<code class="descname">is_orthogonal</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.is_orthogonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if all cell vectors are linearly independent</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.isc_off">
<code class="descname">isc_off</code><a class="headerlink" href="#sisl.Geometry.isc_off" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.isc_off" title="sisl.Geometry.isc_off"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isc_off</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.iter">
<code class="descname">iter</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.iter" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator over all atomic indices</p>
<p>This iterator is the same as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
<span class="gp">... </span>   <span class="o">&lt;</span><span class="n">do</span> <span class="n">something</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>or equivalently</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
<span class="gp">... </span>   <span class="o">&lt;</span><span class="n">do</span> <span class="n">something</span><span class="o">&gt;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.iter_species" title="sisl.Geometry.iter_species"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_species</span></code></a></dt><dd><p>iterate across indices and atomic species</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.iter_orbitals" title="sisl.Geometry.iter_orbitals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_orbitals</span></code></a></dt><dd><p>iterate across atomic indices and orbital indices</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.iter_block">
<code class="descname">iter_block</code><span class="sig-paren">(</span><em>self</em>, <em>iR=20</em>, <em>R=None</em>, <em>atom=None</em>, <em>method='rand'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.iter_block"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.iter_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator for performance critical loops</p>
<p>NOTE: This requires that <em class="xref py py-obj">R</em> has been set correctly as the maximum interaction range.</p>
<p>I.e. the loop would look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ias</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_block</span><span class="p">():</span>
<span class="gp">... </span>   <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">ias</span><span class="p">:</span>
<span class="gp">... </span>       <span class="n">idx_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">R</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idxs</span><span class="p">)</span>
</pre></div>
</div>
<p>This iterator is intended for systems with more than 1000 atoms.</p>
<p>Remark that the iterator used is non-deterministic, i.e. any two iterators need
not return the same atoms in any way.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>iR</strong><span class="classifier">int, optional</span></dt><dd><p>the number of <em class="xref py py-obj">R</em> ranges taken into account when doing the iterator</p>
</dd>
<dt><strong>R</strong><span class="classifier">float, optional</span></dt><dd><p>enables overwriting the local R quantity. Defaults to <code class="docutils literal notranslate"><span class="pre">self.maxR()</span></code></p>
</dd>
<dt><strong>atom</strong><span class="classifier">array_like, optional</span></dt><dd><p>enables only effectively looping a subset of the full geometry</p>
</dd>
<dt><strong>method</strong><span class="classifier">{‘rand’, ‘sphere’, ‘cube’}</span></dt><dd><p>select the method by which the block iteration is performed.
Possible values are:</p>
<blockquote>
<div><p><em class="xref py py-obj">rand</em>: a spherical object is constructed with a random center according to the internal atoms
<em class="xref py py-obj">sphere</em>: a spherical equispaced shape is constructed and looped
<em class="xref py py-obj">cube</em>: a cube shape is constructed and looped</p>
</div></blockquote>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>current list of atoms currently searched</p>
</dd>
<dt>numpy.ndarray</dt><dd><p>atoms that needs searching</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.iter_block_rand">
<code class="descname">iter_block_rand</code><span class="sig-paren">(</span><em>self</em>, <em>iR=20</em>, <em>R=None</em>, <em>atom=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.iter_block_rand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.iter_block_rand" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the <em>random</em> block-iteration by randomly selecting the next center of block</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.iter_block_shape">
<code class="descname">iter_block_shape</code><span class="sig-paren">(</span><em>self</em>, <em>shape=None</em>, <em>iR=20</em>, <em>atom=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.iter_block_shape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.iter_block_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the <em>grid</em> block-iteration by looping a grid</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.iter_orbitals">
<code class="descname">iter_orbitals</code><span class="sig-paren">(</span><em>self</em>, <em>atom=None</em>, <em>local=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.iter_orbitals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.iter_orbitals" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator over all atoms and their associated orbitals</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">io</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_orbitals</span><span class="p">():</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">ia</span></code> being the atomic index, <code class="docutils literal notranslate"><span class="pre">io</span></code> the associated orbital index on atom <code class="docutils literal notranslate"><span class="pre">ia</span></code>.
Note that <code class="docutils literal notranslate"><span class="pre">io</span></code> will start from <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>atom</strong><span class="classifier">int or array_like, optional</span></dt><dd><p>only loop on the given atoms, default to all atoms</p>
</dd>
<dt><strong>local</strong><span class="classifier">bool, optional</span></dt><dd><p>whether the orbital index is the global index, or the local index relative to
the atom it resides on.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.iter" title="sisl.Geometry.iter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter</span></code></a></dt><dd><p>iterate over atomic indices</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.iter_species" title="sisl.Geometry.iter_species"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_species</span></code></a></dt><dd><p>iterate across indices and atomic species</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.iter_species">
<code class="descname">iter_species</code><span class="sig-paren">(</span><em>self</em>, <em>atom=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.iter_species"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.iter_species" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator over all atoms (or a subset) and species as a tuple in this geometry</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">idx_specie</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_species</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">isinstance</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span>
<span class="gp">... </span>    <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span>
<span class="gp">... </span>    <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx_specie</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">ia</span></code> being the atomic index, <code class="docutils literal notranslate"><span class="pre">a</span></code> the <a class="reference internal" href="sisl.Atom.html#sisl.Atom" title="sisl.Atom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Atom</span></code></a> object, <code class="docutils literal notranslate"><span class="pre">idx_specie</span></code>
is the index of the specie</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>atom</strong><span class="classifier">int or array_like, optional</span></dt><dd><p>only loop on the given atoms, default to all atoms</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.iter" title="sisl.Geometry.iter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter</span></code></a></dt><dd><p>iterate over atomic indices</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.iter_orbitals" title="sisl.Geometry.iter_orbitals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_orbitals</span></code></a></dt><dd><p>iterate across atomic indices and orbital indices</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.lasto">
<code class="descname">lasto</code><a class="headerlink" href="#sisl.Geometry.lasto" title="Permalink to this definition">¶</a></dt>
<dd><p>The last orbital on the corresponding atom</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.mass">
<code class="descname">mass</code><a class="headerlink" href="#sisl.Geometry.mass" title="Permalink to this definition">¶</a></dt>
<dd><p>The mass of all atoms as an array</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.maxR">
<code class="descname">maxR</code><span class="sig-paren">(</span><em>self</em>, <em>all=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.maxR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.maxR" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum orbital range of the atoms</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.mirror">
<code class="descname">mirror</code><span class="sig-paren">(</span><em>self</em>, <em>plane</em>, <em>atom=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.mirror"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.mirror" title="Permalink to this definition">¶</a></dt>
<dd><p>Mirrors the atomic coordinates by multiplying by -1</p>
<p>This will typically move the atomic coordinates outside of the unit-cell.
This method should be used with care.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>plane</strong><span class="classifier">{‘xy’/’ab’, ‘yz’/’bc’, ‘xz’/’ac’}</span></dt><dd><p>mirror the structure across the lattice vector plane</p>
</dd>
<dt><strong>atom</strong><span class="classifier">array_like, optional</span></dt><dd><p>only mirror a subset of atoms</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.move">
<code class="descname">move</code><span class="sig-paren">(</span><em>self</em>, <em>v</em>, <em>atom=None</em>, <em>cell=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.move"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.move" title="Permalink to this definition">¶</a></dt>
<dd><p>Translates the geometry by <em class="xref py py-obj">v</em></p>
<p>One can translate a subset of the atoms by supplying <a class="reference internal" href="#sisl.Geometry.atom" title="sisl.Geometry.atom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atom</span></code></a>.</p>
<p>Returns a copy of the structure translated by <em class="xref py py-obj">v</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">array_like</span></dt><dd><p>the vector to displace all atomic coordinates</p>
</dd>
<dt><strong>atom</strong><span class="classifier">int or array_like, optional</span></dt><dd><p>only displace the given atomic indices, if not specified, all
atoms will be displaced</p>
</dd>
<dt><strong>cell</strong><span class="classifier">bool, optional</span></dt><dd><p>If True the supercell also gets enlarged by the vector</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.n_s">
<code class="descname">n_s</code><a class="headerlink" href="#sisl.Geometry.n_s" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.n_s" title="sisl.Geometry.n_s"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_s</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.na">
<code class="descname">na</code><a class="headerlink" href="#sisl.Geometry.na" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of atoms in geometry</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.na_s">
<code class="descname">na_s</code><a class="headerlink" href="#sisl.Geometry.na_s" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of supercell atoms</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.names">
<code class="descname">names</code><a class="headerlink" href="#sisl.Geometry.names" title="Permalink to this definition">¶</a></dt>
<dd><p>The named index specifier</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.no">
<code class="descname">no</code><a class="headerlink" href="#sisl.Geometry.no" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of orbitals</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.no_s">
<code class="descname">no_s</code><a class="headerlink" href="#sisl.Geometry.no_s" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of supercell orbitals</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.nsc">
<code class="descname">nsc</code><a class="headerlink" href="#sisl.Geometry.nsc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.nsc" title="sisl.Geometry.nsc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nsc</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.o2a">
<code class="descname">o2a</code><span class="sig-paren">(</span><em>self</em>, <em>io</em>, <em>unique=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.o2a"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.o2a" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomic index corresponding to the orbital indicies.</p>
<p>This is a particurlaly slow algorithm due to for-loops.</p>
<p>Note that this will preserve the super-cell offsets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>io</strong><span class="classifier">array_like</span></dt><dd><p>List of indices to return the atoms for</p>
</dd>
<dt><strong>unique</strong><span class="classifier">bool, optional</span></dt><dd><p>If True only return the unique atoms.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.o2isc">
<code class="descname">o2isc</code><span class="sig-paren">(</span><em>self</em>, <em>io</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.o2isc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.o2isc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the super-cell index for a specific orbital.</p>
<p>Returns a vector of 3 numbers with integers.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.o2sc">
<code class="descname">o2sc</code><span class="sig-paren">(</span><em>self</em>, <em>o</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.o2sc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.o2sc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the super-cell offset for a specific orbital.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.o2transpose">
<code class="descname">o2transpose</code><span class="sig-paren">(</span><em>self</em>, <em>orb1</em>, <em>orb2=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.o2transpose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.o2transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Transposes connections from <em class="xref py py-obj">orb1</em> to <em class="xref py py-obj">orb2</em> such that supercell connections are transposed</p>
<p>When handling supercell indices it is useful to get the <em>transposed</em> connection. I.e. if you have
a connection from site <code class="docutils literal notranslate"><span class="pre">i</span></code> (in unit cell indices) to site <code class="docutils literal notranslate"><span class="pre">j</span></code> (in supercell indices) it may be
useful to get the equivalent supercell connection such for site <code class="docutils literal notranslate"><span class="pre">j</span></code> (in unit cell indices) to
site <code class="docutils literal notranslate"><span class="pre">i</span></code> (in supercell indices) such that they correspond to the transposed coupling.</p>
<p>Note that since this transposes couplings the indices returned are always expanded to the full
length if either of the inputs are a single index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>orb1</strong><span class="classifier">array_like</span></dt><dd><p>orbital indices must have same length as <em class="xref py py-obj">orb2</em> or length 1</p>
</dd>
<dt><strong>orb2</strong><span class="classifier">array_like, optional</span></dt><dd><p>orbital indices must have same length as <em class="xref py py-obj">orb1</em> or length 1.
If not present then only <em class="xref py py-obj">orb1</em> will be returned in transposed indices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>orb2</strong><span class="classifier">array_like</span></dt><dd><p>transposed indices for orb2 (only returned if <em class="xref py py-obj">orb2</em> is not None)</p>
</dd>
<dt><strong>orb1</strong><span class="classifier">array_like</span></dt><dd><p>transposed indices for orb1</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gr</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">graphene</span><span class="p">()</span> <span class="c1"># one orbital per site</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">gr</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span>
<span class="go">array([0, 1, 5, 9], dtype=int32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gr</span><span class="o">.</span><span class="n">o2transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
<span class="go">(array([0, 1, 1, 1], dtype=int32), array([ 0,  0, 14, 10], dtype=int32))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.oRij">
<code class="descname">oRij</code><span class="sig-paren">(</span><em>self</em>, <em>io</em>, <em>jo</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.oRij"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.oRij" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector between orbital <a class="reference internal" href="sisl.io.html#module-sisl.io" title="sisl.io"><code class="xref py py-obj docutils literal notranslate"><span class="pre">io</span></code></a> and <em class="xref py py-obj">jo</em>, orbitals can be in super-cell indices</p>
<p>Returns the vector between two orbitals:</p>
<div class="math notranslate nohighlight">
\[R_{ij} = r_j - r_i\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>io</strong><span class="classifier">int or array_like</span></dt><dd><p>orbital index of first orbital</p>
</dd>
<dt><strong>jo</strong><span class="classifier">int or array_like</span></dt><dd><p>orbital indices</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.optimize_nsc">
<code class="descname">optimize_nsc</code><span class="sig-paren">(</span><em>self</em>, <em>axis=None</em>, <em>R=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.optimize_nsc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.optimize_nsc" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize the number of supercell connections based on <code class="docutils literal notranslate"><span class="pre">self.maxR()</span></code></p>
<p>After this routine the number of supercells may not necessarily be the same.</p>
<p>This is an in-place operation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">int or array_like, optional</span></dt><dd><p>only optimize the specified axis (default to all)</p>
</dd>
<dt><strong>R</strong><span class="classifier">float, optional</span></dt><dd><p>the maximum connection radius for each atom</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.orbitals">
<code class="descname">orbitals</code><a class="headerlink" href="#sisl.Geometry.orbitals" title="Permalink to this definition">¶</a></dt>
<dd><p>List of orbitals per atom</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.origo">
<code class="descname">origo</code><a class="headerlink" href="#sisl.Geometry.origo" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.origo" title="sisl.Geometry.origo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">origo</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.orij">
<code class="descname">orij</code><span class="sig-paren">(</span><em>self</em>, <em>io</em>, <em>jo</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.orij"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.orij" title="Permalink to this definition">¶</a></dt>
<dd><p>Distance between orbital <a class="reference internal" href="sisl.io.html#module-sisl.io" title="sisl.io"><code class="xref py py-obj docutils literal notranslate"><span class="pre">io</span></code></a> and <em class="xref py py-obj">jo</em>, orbitals can be in super-cell indices</p>
<p>Returns the distance between two orbitals:</p>
<div class="math notranslate nohighlight">
\[r_{ij} = |r_j - r_i|\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>io</strong><span class="classifier">int or array_like</span></dt><dd><p>orbital index of first orbital</p>
</dd>
<dt><strong>jo</strong><span class="classifier">int or array_like</span></dt><dd><p>orbital indices</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.osc2uc">
<code class="descname">osc2uc</code><span class="sig-paren">(</span><em>self</em>, <em>orb</em>, <em>unique=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.osc2uc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.osc2uc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns orbitals from supercell indices to unit-cell indices, possibly removing dublicates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>orb</strong><span class="classifier">array_like or int</span></dt><dd><p>the orbital supercell indices to be converted to unit-cell indices</p>
</dd>
<dt><strong>unique</strong><span class="classifier">bool, optional</span></dt><dd><p>If True the returned indices are unique and sorted.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.ouc2sc">
<code class="descname">ouc2sc</code><span class="sig-paren">(</span><em>self</em>, <em>orb</em>, <em>unique=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.ouc2sc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.ouc2sc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns orbitals from unit-cell indices to supercell indices, possibly removing dublicates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>orb</strong><span class="classifier">array_like or int</span></dt><dd><p>the orbital unit-cell indices to be converted to supercell indices</p>
</dd>
<dt><strong>unique</strong><span class="classifier">bool, optional</span></dt><dd><p>If True the returned indices are unique and sorted.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.prepend">
<code class="descname">prepend</code><span class="sig-paren">(</span><em>self</em>, <em>other</em>, <em>axis</em>, <em>align='none'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.prepend"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.prepend" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepend two structures along <em class="xref py py-obj">axis</em></p>
<p>This will automatically add the <code class="docutils literal notranslate"><span class="pre">self.cell[axis,:]</span></code> to all atomic
coordiates in the <em class="xref py py-obj">other</em> structure before appending.</p>
<p>The basic algorithm is this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">oxa</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">xyz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oxa</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:][</span><span class="kc">None</span><span class="p">,:])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:]</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:]</span>
</pre></div>
</div>
<p>NOTE: The cell prepended is only in the axis that
is prependend, which means that the other cell directions
need not conform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Geometry or SuperCell</span></dt><dd><p>Other geometry class which needs to be prepended
If a <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> only the super cell will be extended</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>Cell direction to which the <em class="xref py py-obj">other</em> geometry should be
prepended</p>
</dd>
<dt><strong>align</strong><span class="classifier">{‘none’, ‘min’}</span></dt><dd><p>By default prepending two structures will simply use the coordinates,
as is.
With ‘min’, the routine will shift both the structures along the cell
axis of <em class="xref py py-obj">other</em> such that they coincide at the first atom.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.add" title="sisl.Geometry.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add</span></code></a></dt><dd><p>add geometries</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.append" title="sisl.Geometry.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a></dt><dd><p>appending geometries</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.attach" title="sisl.Geometry.attach"><code class="xref py py-obj docutils literal notranslate"><span class="pre">attach</span></code></a></dt><dd><p>attach a geometry</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.insert" title="sisl.Geometry.insert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">insert</span></code></a></dt><dd><p>insert a geometry</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.q0">
<code class="descname">q0</code><a class="headerlink" href="#sisl.Geometry.q0" title="Permalink to this definition">¶</a></dt>
<dd><p>Total initial charge in this geometry (sum of q0 in all atoms)</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.rcell">
<code class="descname">rcell</code><a class="headerlink" href="#sisl.Geometry.rcell" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.rcell" title="sisl.Geometry.rcell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rcell</span></code></a></p>
</dd></dl>

<dl class="staticmethod">
<dt id="sisl.Geometry.read">
<em class="property">static </em><code class="descname">read</code><span class="sig-paren">(</span><em>sile</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.read"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads geometry from the <code class="xref py py-obj docutils literal notranslate"><span class="pre">Sile</span></code> using <em class="xref py py-obj">Sile.read_geometry</em></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sile</strong><span class="classifier">Sile, str or pathlib.Path</span></dt><dd><p>a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Sile</span></code> object which will be used to read the geometry
if it is a string it will create a new sile using <code class="xref py py-obj docutils literal notranslate"><span class="pre">get_sile</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.write" title="sisl.Geometry.write"><code class="xref py py-obj docutils literal notranslate"><span class="pre">write</span></code></a></dt><dd><p>writes a <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry</span></code></a> to a given <code class="xref py py-obj docutils literal notranslate"><span class="pre">Sile</span></code>/file</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.reduce">
<code class="descname">reduce</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.reduce"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all atoms not currently used in the <code class="docutils literal notranslate"><span class="pre">self.atoms</span></code> object</p>
<p class="rubric">Notes</p>
<p>This is an in-place operation.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>self</em>, <em>atom</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.remove"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove atoms from the geometry.</p>
<p>Indices passed <em>MUST</em> be unique.</p>
<p>Negative indices are wrapped and thus works.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>atom</strong><span class="classifier">int or array_like</span></dt><dd><p>indices/boolean of all atoms to be removed</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.sub" title="sisl.Geometry.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub</span></code></a></dt><dd><p>the negative of this routine, i.e. retain a subset of atoms</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.reorder">
<code class="descname">reorder</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.reorder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.reorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorders atoms according to first occurence in the geometry</p>
<p class="rubric">Notes</p>
<p>This is an in-place operation.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.repeat">
<code class="descname">repeat</code><span class="sig-paren">(</span><em>self</em>, <em>reps</em>, <em>axis</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.repeat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a repeated geometry</p>
<p>The atomic indices are <em>NOT</em> retained from the base structure.</p>
<p>The expansion of the atoms are basically performed using this
algorithm:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ja</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="nb">id</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
<span class="gp">... </span>       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
<span class="gp">... </span>          <span class="n">ja</span> <span class="o">=</span> <span class="n">ia</span> <span class="o">+</span> <span class="n">cell</span><span class="p">[</span><span class="nb">id</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">i</span>
</pre></div>
</div>
<p>This method allows to utilise Bloch’s theorem when creating
Hamiltonian parameter sets for TBtrans.</p>
<p>For geometries with a single atom this routine returns the same as
<a class="reference internal" href="#sisl.Geometry.tile" title="sisl.Geometry.tile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tile</span></code></a>.</p>
<p>Tiling and repeating a geometry will result in the same geometry.
The <em>only</em> difference between the two is the final ordering of the atoms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reps</strong><span class="classifier">int</span></dt><dd><p>number of repetitions</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>direction of repetition, 0, 1, 2 according to the cell-direction</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.tile" title="sisl.Geometry.tile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tile</span></code></a></dt><dd><p>equivalent but different ordering of final structure</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">sc</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span> <span class="c1"># doctest: +NORMALIZE_WHITESPACE</span>
<span class="go">[[0.   0.   0. ]</span>
<span class="go"> [1.   0.   0. ]</span>
<span class="go"> [0.5  0.   0. ]</span>
<span class="go"> [1.5  0.   0. ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span> <span class="c1"># doctest: +NORMALIZE_WHITESPACE</span>
<span class="go">[[0.   0.   0. ]</span>
<span class="go"> [0.   1.   0. ]</span>
<span class="go"> [1.   0.   0. ]</span>
<span class="go"> [1.   1.   0. ]</span>
<span class="go"> [0.5  0.   0. ]</span>
<span class="go"> [0.5  1.   0. ]</span>
<span class="go"> [1.5  0.   0. ]</span>
<span class="go"> [1.5  1.   0. ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.reverse">
<code class="descname">reverse</code><span class="sig-paren">(</span><em>self</em>, <em>atom=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.reverse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reversed geometry</p>
<p>Also enables reversing a subset of the atoms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>atom</strong><span class="classifier">int or array_like, optional</span></dt><dd><p>only reverse the given atomic indices, if not specified, all
atoms will be reversed</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.rij">
<code class="descname">rij</code><span class="sig-paren">(</span><em>self</em>, <em>ia</em>, <em>ja</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.rij"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.rij" title="Permalink to this definition">¶</a></dt>
<dd><p>Distance between atom <em class="xref py py-obj">ia</em> and <em class="xref py py-obj">ja</em>, atoms can be in super-cell indices</p>
<p>Returns the distance between two atoms:</p>
<div class="math notranslate nohighlight">
\[r_{ij} = |r_j - r_i|\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ia</strong><span class="classifier">int or array_like</span></dt><dd><p>atomic index of first atom</p>
</dd>
<dt><strong>ja</strong><span class="classifier">int or array_like</span></dt><dd><p>atomic indices</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>self</em>, <em>angle</em>, <em>v</em>, <em>origo=None</em>, <em>atom=None</em>, <em>only='abc+xyz'</em>, <em>rad=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.rotate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate geometry around vector and return a new geometry</p>
<p>Per default will the entire geometry be rotated, such that everything
is aligned as before rotation.</p>
<p>However, by supplying <code class="docutils literal notranslate"><span class="pre">only</span> <span class="pre">=</span> <span class="pre">'abc|xyz'</span></code> one can designate which
part of the geometry that will be rotated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>angle</strong><span class="classifier">float</span></dt><dd><p>the angle in degrees to rotate the geometry. Set the <code class="docutils literal notranslate"><span class="pre">rad</span></code>
argument to use radians.</p>
</dd>
<dt><strong>v</strong><span class="classifier">array_like</span></dt><dd><p>the normal vector to the rotated plane, i.e.
v = [1,0,0] will rotate the <code class="docutils literal notranslate"><span class="pre">yz</span></code> plane</p>
</dd>
<dt><strong>origo</strong><span class="classifier">int or array_like, optional</span></dt><dd><p>the origin of rotation. Anything but [0, 0, 0] is equivalent
to a <em class="xref py py-obj">self.move(-origo).rotate(…).move(origo)</em>.
If this is an <em class="xref py py-obj">int</em> it corresponds to the atomic index.</p>
</dd>
<dt><strong>atom</strong><span class="classifier">int or array_like, optional</span></dt><dd><p>only rotate the given atomic indices, if not specified, all
atoms will be rotated.</p>
</dd>
<dt><strong>only</strong><span class="classifier">{‘abc+xyz’, ‘xyz’, ‘abc’}</span></dt><dd><p>which coordinate subject should be rotated,
if <code class="docutils literal notranslate"><span class="pre">abc</span></code> is in this string the cell will be rotated
if <code class="docutils literal notranslate"><span class="pre">xyz</span></code> is in this string the coordinates will be rotated</p>
</dd>
<dt><strong>rad</strong><span class="classifier">bool, optional</span></dt><dd><p>if <code class="docutils literal notranslate"><span class="pre">True</span></code> the angle is provided in radians (rather than degrees)</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="sisl.Quaternion.html#sisl.Quaternion" title="sisl.Quaternion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Quaternion</span></code></a></dt><dd><p>class to rotate</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.rotate_miller">
<code class="descname">rotate_miller</code><span class="sig-paren">(</span><em>self</em>, <em>m</em>, <em>v</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.rotate_miller"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.rotate_miller" title="Permalink to this definition">¶</a></dt>
<dd><p>Align Miller direction along <code class="docutils literal notranslate"><span class="pre">v</span></code></p>
<p>Rotate geometry and cell such that the Miller direction
points along the Cartesian vector <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.sc2uc">
<code class="descname">sc2uc</code><span class="sig-paren">(</span><em>self</em>, <em>atom</em>, <em>unique=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.sc2uc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.sc2uc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns atom from supercell indices to unit-cell indices, possibly removing dublicates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>atom</strong><span class="classifier">array_like or int</span></dt><dd><p>the atomic supercell indices to be converted to unit-cell indices</p>
</dd>
<dt><strong>unique</strong><span class="classifier">bool, optional</span></dt><dd><p>If True the returned indices are unique and sorted.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.sc_index">
<code class="descname">sc_index</code><span class="sig-paren">(</span><em>self</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.sc_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Call local <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> object <a class="reference internal" href="#sisl.Geometry.sc_index" title="sisl.Geometry.sc_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sc_index</span></code></a> function</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.sc_off">
<code class="descname">sc_off</code><a class="headerlink" href="#sisl.Geometry.sc_off" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.sc_off" title="sisl.Geometry.sc_off"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sc_off</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.scale">
<code class="descname">scale</code><span class="sig-paren">(</span><em>self</em>, <em>scale</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.scale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale coordinates and unit-cell to get a new geometry with proper scaling</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>scale</strong><span class="classifier">float</span></dt><dd><p>the scale factor for the new geometry (lattice vectors, coordinates
and the atomic radii are scaled).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.set_nsc">
<code class="descname">set_nsc</code><span class="sig-paren">(</span><em>self</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.set_nsc" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the number of super-cells in the <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> object</p>
<p>See <a class="reference internal" href="#sisl.Geometry.set_nsc" title="sisl.Geometry.set_nsc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_nsc</span></code></a> for allowed parameters.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell.set_nsc" title="sisl.SuperCell.set_nsc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell.set_nsc</span></code></a></dt><dd><p>the underlying called method</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.set_sc">
<code class="descname">set_sc</code><span class="sig-paren">(</span><em>self</em>, <em>sc</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.set_sc" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrites the local supercell</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.set_supercell">
<code class="descname">set_supercell</code><span class="sig-paren">(</span><em>self</em>, <em>sc</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.set_supercell" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrites the local supercell</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.sort">
<code class="descname">sort</code><span class="sig-paren">(</span><em>self</em>, <em>axes=(2</em>, <em>1</em>, <em>0)</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.sort"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an equivalent geometry by sorting the coordinates according to the axis orders</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axes</strong><span class="classifier">tuple, optional</span></dt><dd><p>sorting axes (note the last element has highest precedence)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Geometry</dt><dd><p>sorted geometry</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.sparserij">
<code class="descname">sparserij</code><span class="sig-paren">(</span><em>self</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em>, <em>na_iR=1000</em>, <em>method='rand'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.sparserij"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.sparserij" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sparse matrix with all distances in the matrix</p>
<p>The sparse matrix will only be defined for the elements which have
orbitals overlapping with other atoms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">numpy.dtype, numpy.float64</span></dt><dd><p>the data-type of the sparse matrix</p>
</dd>
<dt><strong>na_iR</strong><span class="classifier">int, 1000</span></dt><dd><p>number of atoms within the sphere for speeding
up the <a class="reference internal" href="#sisl.Geometry.iter_block" title="sisl.Geometry.iter_block"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_block</span></code></a> loop.</p>
</dd>
<dt><strong>method</strong><span class="classifier">str, optional</span></dt><dd><p>see <a class="reference internal" href="#sisl.Geometry.iter_block" title="sisl.Geometry.iter_block"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_block</span></code></a> for details</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>SparseAtom</dt><dd><p>sparse matrix with all rij elements</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.iter_block" title="sisl.Geometry.iter_block"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_block</span></code></a></dt><dd><p>the method for looping the atoms</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.distance" title="sisl.Geometry.distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">distance</span></code></a></dt><dd><p>create a list of distances</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.sub">
<code class="descname">sub</code><span class="sig-paren">(</span><em>self</em>, <em>atom</em>, <em>cell=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.sub"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry</span></code></a> with a subset of this <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry</span></code></a></p>
<p>Indices passed <em>MUST</em> be unique.</p>
<p>Negative indices are wrapped and thus works.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>atom</strong><span class="classifier">int or array_like</span></dt><dd><p>indices/boolean of all atoms to be removed</p>
</dd>
<dt><strong>cell</strong><span class="classifier">array_like or SuperCell, optional</span></dt><dd><p>the new associated cell of the geometry (defaults to the same cell)</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell.fit" title="sisl.SuperCell.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell.fit</span></code></a></dt><dd><p>update the supercell according to a reference supercell</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.remove" title="sisl.Geometry.remove"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove</span></code></a></dt><dd><p>the negative of this routine, i.e. remove a subset of atoms</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.swap">
<code class="descname">swap</code><span class="sig-paren">(</span><em>self</em>, <em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.swap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.swap" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap a set of atoms in the geometry and return a new one</p>
<p>This can be used to reorder elements of a geometry.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>the first list of atomic coordinates</p>
</dd>
<dt><strong>b</strong><span class="classifier">array_like</span></dt><dd><p>the second list of atomic coordinates</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.swapaxes">
<code class="descname">swapaxes</code><span class="sig-paren">(</span><em>self</em>, <em>a</em>, <em>b</em>, <em>swap='cell+xyz'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.swapaxes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.swapaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap the axis for the atomic coordinates and the cell vectors</p>
<p>If <code class="docutils literal notranslate"><span class="pre">swapaxes(0,1)</span></code> it returns the 0 and 1 values
swapped in the <code class="docutils literal notranslate"><span class="pre">cell</span></code> variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">int</span></dt><dd><p>axes 1, swaps with <em class="xref py py-obj">b</em></p>
</dd>
<dt><strong>b</strong><span class="classifier">int</span></dt><dd><p>axes 2, swaps with <em class="xref py py-obj">a</em></p>
</dd>
<dt><strong>swap</strong><span class="classifier">{‘cell+xyz’, ‘cell’, ‘xyz’}</span></dt><dd><p>decide what to swap, if <em class="xref py py-obj">‘cell’</em> is in <a class="reference internal" href="#sisl.Geometry.swap" title="sisl.Geometry.swap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap</span></code></a> then
the cell axis are swapped.
if <em class="xref py py-obj">‘xyz’</em> is in <a class="reference internal" href="#sisl.Geometry.swap" title="sisl.Geometry.swap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap</span></code></a> then
the xyz (Cartesian) axis are swapped.
Both may be in <a class="reference internal" href="#sisl.Geometry.swap" title="sisl.Geometry.swap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.tile">
<code class="descname">tile</code><span class="sig-paren">(</span><em>self</em>, <em>reps</em>, <em>axis</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.tile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.tile" title="Permalink to this definition">¶</a></dt>
<dd><p>Tile the geometry to create a bigger one</p>
<p>The atomic indices are retained for the base structure.</p>
<p>This method allows to utilise Bloch’s theorem when creating
Hamiltonian parameter sets for TBtrans.</p>
<p>Tiling and repeating a geometry will result in the same geometry.
The <em>only</em> difference between the two is the final ordering of the atoms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reps</strong><span class="classifier">int</span></dt><dd><p>number of tiles (repetitions)</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>direction of tiling, 0, 1, 2 according to the cell-direction</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.repeat" title="sisl.Geometry.repeat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">repeat</span></code></a></dt><dd><p>equivalent but different ordering of final structure</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.cut" title="sisl.Geometry.cut"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cut</span></code></a></dt><dd><p>opposite method of this</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">sc</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span> <span class="c1"># doctest: +NORMALIZE_WHITESPACE</span>
<span class="go">[[0.   0.   0. ]</span>
<span class="go"> [0.5  0.   0. ]</span>
<span class="go"> [1.   0.   0. ]</span>
<span class="go"> [1.5  0.   0. ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span> <span class="c1"># doctest: +NORMALIZE_WHITESPACE</span>
<span class="go">[[0.   0.   0. ]</span>
<span class="go"> [0.5  0.   0. ]</span>
<span class="go"> [1.   0.   0. ]</span>
<span class="go"> [1.5  0.   0. ]</span>
<span class="go"> [0.   1.   0. ]</span>
<span class="go"> [0.5  1.   0. ]</span>
<span class="go"> [1.   1.   0. ]</span>
<span class="go"> [1.5  1.   0. ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.toASE">
<code class="descname">toASE</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.toASE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.toASE" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the geometry as an ASE <code class="docutils literal notranslate"><span class="pre">Atoms</span></code> object</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.translate">
<code class="descname">translate</code><span class="sig-paren">(</span><em>self</em>, <em>v</em>, <em>atom=None</em>, <em>cell=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Translates the geometry by <em class="xref py py-obj">v</em></p>
<p>One can translate a subset of the atoms by supplying <a class="reference internal" href="#sisl.Geometry.atom" title="sisl.Geometry.atom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atom</span></code></a>.</p>
<p>Returns a copy of the structure translated by <em class="xref py py-obj">v</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">array_like</span></dt><dd><p>the vector to displace all atomic coordinates</p>
</dd>
<dt><strong>atom</strong><span class="classifier">int or array_like, optional</span></dt><dd><p>only displace the given atomic indices, if not specified, all
atoms will be displaced</p>
</dd>
<dt><strong>cell</strong><span class="classifier">bool, optional</span></dt><dd><p>If True the supercell also gets enlarged by the vector</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.uc2sc">
<code class="descname">uc2sc</code><span class="sig-paren">(</span><em>self</em>, <em>atom</em>, <em>unique=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.uc2sc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.uc2sc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns atom from unit-cell indices to supercell indices, possibly removing dublicates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>atom</strong><span class="classifier">array_like or int</span></dt><dd><p>the atomic unit-cell indices to be converted to supercell indices</p>
</dd>
<dt><strong>unique</strong><span class="classifier">bool, optional</span></dt><dd><p>If True the returned indices are unique and sorted.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="sisl.Geometry.volume">
<code class="descname">volume</code><a class="headerlink" href="#sisl.Geometry.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <em class="xref py py-obj">vol</em></p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.within">
<code class="descname">within</code><span class="sig-paren">(</span><em>self</em>, <em>shapes</em>, <em>idx=None</em>, <em>idx_xyz=None</em>, <em>ret_xyz=False</em>, <em>ret_rij=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.within"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.within" title="Permalink to this definition">¶</a></dt>
<dd><p>Indices of atoms in the entire supercell within a given shape from a given coordinate</p>
<p>This heavily relies on the <a class="reference internal" href="#sisl.Geometry.within_sc" title="sisl.Geometry.within_sc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">within_sc</span></code></a> method.</p>
<p>Note that if a connection is made in a neighbouring super-cell
then the atomic index is shifted by the super-cell index times
number of atoms.
This allows one to decipher super-cell atoms from unit-cell atoms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shapes</strong><span class="classifier">Shape, list of Shape</span></dt><dd></dd>
<dt><strong>idx</strong><span class="classifier">array_like, optional</span></dt><dd><p>List of indices for atoms that are to be considered</p>
</dd>
<dt><strong>idx_xyz</strong><span class="classifier">array_like, optional</span></dt><dd><p>The atomic coordinates of the equivalent <em class="xref py py-obj">idx</em> variable (<em class="xref py py-obj">idx</em> must also be passed)</p>
</dd>
<dt><strong>ret_xyz</strong><span class="classifier">bool, optional</span></dt><dd><p>If true this method will return the coordinates
for each of the couplings.</p>
</dd>
<dt><strong>ret_rij</strong><span class="classifier">bool, optional</span></dt><dd><p>If true this method will return the distances from the <em class="xref py py-obj">xyz_ia</em>
for each of the couplings.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>index</dt><dd><p>indices of atoms (in supercell indices) within the shape</p>
</dd>
<dt>xyz</dt><dd><p>atomic coordinates of the indexed atoms (only for true <em class="xref py py-obj">ret_xyz</em>)</p>
</dd>
<dt>rij</dt><dd><p>distance of the indexed atoms to the center of the shape (only for true <em class="xref py py-obj">ret_rij</em>)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.within_inf">
<code class="descname">within_inf</code><span class="sig-paren">(</span><em>self</em>, <em>sc</em>, <em>periodic=None</em>, <em>tol=1e-05</em>, <em>origo=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.within_inf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.within_inf" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all atoms within a provided supercell</p>
<p>Note this function is rather different from <a class="reference internal" href="#sisl.Geometry.close" title="sisl.Geometry.close"><code class="xref py py-obj docutils literal notranslate"><span class="pre">close</span></code></a> and <a class="reference internal" href="#sisl.Geometry.within" title="sisl.Geometry.within"><code class="xref py py-obj docutils literal notranslate"><span class="pre">within</span></code></a>.
Specifically this routine is returning <em>all</em> indices for the infinite
periodic system (where <code class="docutils literal notranslate"><span class="pre">self.nsc</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> or <em class="xref py py-obj">periodic</em> is true).</p>
<p>Atomic coordinates lying on the boundary of the supercell will be duplicated
on the neighbouring supercell images. Thus performing <em class="xref py py-obj">geom.within_inf(geom.sc)</em>
may result in more atoms than in the structure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sc</strong><span class="classifier">SuperCell or SuperCellChild</span></dt><dd><p>the supercell in which this geometry should be expanded into.</p>
</dd>
<dt><strong>periodic</strong><span class="classifier">list of bool</span></dt><dd><p>explicitly define the periodic directions, by default the periodic
directions are only where <code class="docutils literal notranslate"><span class="pre">self.nsc</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float, optional</span></dt><dd><p>length tolerance for the fractional coordinates to be on a duplicate site (in Ang).
This allows atoms within <em class="xref py py-obj">tol</em> of the cell boundaries to be taken as <em>inside</em> the
cell.</p>
</dd>
<dt><strong>origo</strong><span class="classifier">(3, ) of float</span></dt><dd><p>origo that is the basis for comparison</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>unit-cell atomic indices which are inside the <em class="xref py py-obj">sc</em> cell</p>
</dd>
<dt>numpy.ndarray</dt><dd><p>atomic coordinates for the <em class="xref py py-obj">ia</em> atoms (including supercell offsets)</p>
</dd>
<dt>numpy.ndarray</dt><dd><p>integer supercell offsets for <em class="xref py py-obj">ia</em> atoms</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The name of this function may change. Currently it should only be used
internally in sisl.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.within_sc">
<code class="descname">within_sc</code><span class="sig-paren">(</span><em>self</em>, <em>shapes</em>, <em>isc=None</em>, <em>idx=None</em>, <em>idx_xyz=None</em>, <em>ret_xyz=False</em>, <em>ret_rij=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.within_sc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.within_sc" title="Permalink to this definition">¶</a></dt>
<dd><p>Indices of atoms in a given supercell within a given shape from a given coordinate</p>
<p>This returns a set of atomic indices which are within a
sphere of radius <code class="docutils literal notranslate"><span class="pre">R</span></code>.</p>
<p>If R is a tuple/list/array it will return the indices:
in the ranges:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>shapes</strong><span class="classifier">Shape or list of Shape</span></dt><dd><p>A list of increasing shapes that define the extend of the geometric
volume that is searched.
It is vital that:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">...</span>
</pre></div>
</div>
</dd>
<dt><strong>isc</strong><span class="classifier">array_like, optional</span></dt><dd><p>The super-cell which the coordinates are checked in. Defaults to <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0]</span></code></p>
</dd>
<dt><strong>idx</strong><span class="classifier">array_like, optional</span></dt><dd><p>List of atoms that will be considered. This can
be used to only take out a certain atoms.</p>
</dd>
<dt><strong>idx_xyz</strong><span class="classifier">array_like, optional</span></dt><dd><p>The atomic coordinates of the equivalent <em class="xref py py-obj">idx</em> variable (<em class="xref py py-obj">idx</em> must also be passed)</p>
</dd>
<dt><strong>ret_xyz</strong><span class="classifier">bool, optional</span></dt><dd><p>If True this method will return the coordinates
for each of the couplings.</p>
</dd>
<dt><strong>ret_rij</strong><span class="classifier">bool, optional</span></dt><dd><p>If True this method will return the distance to the center of the shapes</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>index</dt><dd><p>indices of atoms (in supercell indices) within the shape</p>
</dd>
<dt>xyz</dt><dd><p>atomic coordinates of the indexed atoms (only for true <em class="xref py py-obj">ret_xyz</em>)</p>
</dd>
<dt>rij</dt><dd><p>distance of the indexed atoms to the center of the shape (only for true <em class="xref py py-obj">ret_rij</em>)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.Geometry.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>self</em>, <em>sile</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/geometry.html#Geometry.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.Geometry.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes geometry to the <code class="xref py py-obj docutils literal notranslate"><span class="pre">Sile</span></code> using <em class="xref py py-obj">sile.write_geometry</em></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sile</strong><span class="classifier">Sile, str or pathlib.Path</span></dt><dd><p>a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Sile</span></code> object which will be used to write the geometry
if it is a string it will create a new sile using <code class="xref py py-obj docutils literal notranslate"><span class="pre">get_sile</span></code></p>
</dd>
<dt><strong>*args, **kwargs:</strong></dt><dd><p>Any other args will be passed directly to the
underlying routine</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.read" title="sisl.Geometry.read"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read</span></code></a></dt><dd><p>reads a <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry</span></code></a> from a given <code class="xref py py-obj docutils literal notranslate"><span class="pre">Sile</span></code>/file</p>
</dd>
</dl>
</div>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="sisl.SuperCell.html" class="btn btn-neutral float-right" title="SuperCell" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="sisl.Atoms.html" class="btn btn-neutral float-left" title="Atoms" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2018, Nick Papior

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>